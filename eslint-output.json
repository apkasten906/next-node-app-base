[
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\config\\multer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\config\\swagger.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 258,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 258,
        "endColumn": 14,
        "suggestions": [
          {
            "fix": { "range": [6113, 6176], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "Startup information logging" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 260,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 260,
        "endColumn": 14,
        "suggestions": [
          {
            "fix": { "range": [6251, 6310], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "Startup information logging" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\container.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\controllers\\user.controller.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\middleware\\api-version.middleware.ts",
    "messages": [
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 78,
        "column": 18,
        "nodeType": "MemberExpression",
        "endLine": 78,
        "endColumn": 27
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 79,
        "column": 18,
        "nodeType": "MemberExpression",
        "endLine": 79,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { NextFunction, Request, Response } from 'express';\n\nexport interface ApiVersionMiddlewareOptions {\n  defaultVersion?: string;\n  supportedVersions?: string[];\n  header?: string;\n}\n\n/**\n * Middleware to extract and validate API version from headers\n * Version format: application/vnd.api+json; version=1.0\n */\nexport function apiVersionMiddleware(options: ApiVersionMiddlewareOptions = {}) {\n  const { defaultVersion = '1.0', supportedVersions = ['1.0'], header = 'accept' } = options;\n\n  return (req: Request, res: Response, next: NextFunction): void => {\n    let version = defaultVersion;\n\n    const acceptHeader = req.get(header);\n    if (acceptHeader) {\n      // Extract version from Accept header\n      const versionMatch = acceptHeader.match(/version=([0-9.]+)/);\n      if (versionMatch && versionMatch[1]) {\n        version = versionMatch[1];\n      }\n    }\n\n    // Check if version is supported\n    if (!supportedVersions.includes(version)) {\n      res.status(400).json({\n        error: 'Unsupported API version',\n        message: `API version ${version} is not supported. Supported versions: ${supportedVersions.join(', ')}`,\n        supportedVersions,\n      });\n      return;\n    }\n\n    // Attach version to request object\n    req.apiVersion = version;\n\n    // Set version in response header\n    res.setHeader('API-Version', version);\n\n    next();\n  };\n}\n\n/**\n * Helper to check if request is for a specific version or higher\n */\nexport function requireVersion(minVersion: string) {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    const currentVersion = req.apiVersion || '1.0';\n\n    if (compareVersions(currentVersion, minVersion) < 0) {\n      res.status(400).json({\n        error: 'API version too old',\n        message: `This endpoint requires API version ${minVersion} or higher`,\n        currentVersion,\n        requiredVersion: minVersion,\n      });\n      return;\n    }\n\n    next();\n  };\n}\n\n/**\n * Compare two semantic version strings\n * Returns: -1 if a < b, 0 if a === b, 1 if a > b\n */\nfunction compareVersions(a: string, b: string): number {\n  const aParts = a.split('.').map(Number);\n  const bParts = b.split('.').map(Number);\n\n  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    const aNum = aParts[i] || 0;\n    const bNum = bParts[i] || 0;\n\n    if (aNum > bNum) return 1;\n    if (aNum < bNum) return -1;\n  }\n\n  return 0;\n}\n\n/**\n * Get API version from request\n */\nexport function getApiVersion(req: Request): string {\n  return req.apiVersion || '1.0';\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\middleware\\auth.middleware.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-namespace",
        "severity": 2,
        "message": "ES2015 module syntax is preferred over namespaces.",
        "line": 11,
        "column": 3,
        "nodeType": "TSModuleDeclaration",
        "messageId": "moduleSyntaxIsPreferred",
        "endLine": 15,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'_error' is defined but never used.",
        "line": 40,
        "column": 12,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 40,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { TokenPayload } from '@repo/types';\nimport { NextFunction, Request, Response } from 'express';\nimport { container } from 'tsyringe';\n\nimport { AuthorizationService } from '../services/auth/authorization.service';\nimport { JwtService } from '../services/auth/jwt.service';\n\n// Extend Express Request to include user\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: TokenPayload;\n    }\n  }\n}\n\n/**\n * Middleware to authenticate JWT token\n */\nexport const authenticate = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n    if (!token) {\n      res.status(401).json({ error: 'No token provided' });\n      return;\n    }\n\n    const jwtService = container.resolve(JwtService);\n    const payload = await jwtService.validateAccessToken(token);\n\n    req.user = payload;\n    next();\n  } catch (_error) {\n    res.status(403).json({ error: 'Invalid or expired token' });\n  }\n};\n\n/**\n * Middleware factory to check for required roles\n */\nexport const requireRole = (...roles: string[]) => {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    if (!req.user) {\n      res.status(401).json({ error: 'Unauthorized' });\n      return;\n    }\n\n    const authService = container.resolve(AuthorizationService);\n    const userId = req.user['userId'];\n\n    for (const role of roles) {\n      const hasRole = await authService.hasRole(userId, role);\n      if (hasRole) {\n        next();\n        return;\n      }\n    }\n\n    res\n      .status(403)\n      .json({ error: 'Insufficient permissions - required roles: ' + roles.join(', ') });\n  };\n};\n\n/**\n * Middleware factory to check for required permissions\n */\nexport const requirePermission = (...permissions: string[]) => {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    if (!req.user) {\n      res.status(401).json({ error: 'Unauthorized' });\n      return;\n    }\n\n    const authService = container.resolve(AuthorizationService);\n    const userId = req.user['userId'];\n\n    for (const permission of permissions) {\n      const hasPermission = await authService.hasPermission(userId, permission);\n      if (!hasPermission) {\n        res\n          .status(403)\n          .json({ error: 'Insufficient permissions - required: ' + permissions.join(', ') });\n        return;\n      }\n    }\n\n    next();\n  };\n};\n\n/**\n * Middleware factory to check resource access\n */\nexport const requireAccess = (resource: string, action: string) => {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    if (!req.user) {\n      res.status(401).json({ error: 'Unauthorized' });\n      return;\n    }\n\n    const authService = container.resolve(AuthorizationService);\n    const userId = req.user['userId'];\n\n    const canAccess = await authService.canAccess(userId, resource, action);\n\n    if (!canAccess) {\n      res.status(403).json({ error: `Access denied for ${action} on ${resource}` });\n      return;\n    }\n\n    next();\n  };\n};\n\n/**\n * Optional authentication - sets user if token is valid but doesn't fail if not\n */\nexport const optionalAuth = async (\n  req: Request,\n  _res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];\n\n    if (token) {\n      const jwtService = container.resolve(JwtService);\n      const payload = await jwtService.validateAccessToken(token);\n      req.user = payload;\n    }\n  } catch {\n    // Ignore errors - authentication is optional\n  }\n\n  next();\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\middleware\\security.middleware.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\repositories\\user.repository.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\routes\\files.routes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\routes\\user.routes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\routes\\users-v2.routes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 73,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 73,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2578, 2581], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2578, 2581], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 179,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 179,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5665, 5668], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5665, 5668], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Router, type NextFunction, type Request, type Response } from 'express';\r\nimport { container } from 'tsyringe';\r\n\r\nimport { AuthorizationService } from '../services/auth/authorization.service';\r\nimport { DatabaseService } from '../services/database.service';\r\nimport { createCollectionLinks, createResourceLinks } from '../utils/hateoas';\r\nimport {\r\n  filtersToPrismaWhere,\r\n  getPaginationParams,\r\n  getSkipTake,\r\n  parseFilters,\r\n  parseSorting,\r\n  sortToPrismaOrderBy,\r\n} from '../utils/query-helpers';\r\n\r\nconst router: import('express').Router = Router();\r\n\r\n/**\r\n * @swagger\r\n * /api/users:\r\n *   get:\r\n *     summary: List all users with pagination\r\n *     description: Retrieve a paginated list of users with filtering and sorting\r\n *     tags: [Users]\r\n *     security:\r\n *       - bearerAuth: []\r\n *     parameters:\r\n *       - $ref: '#/components/parameters/PageParam'\r\n *       - $ref: '#/components/parameters/PageSizeParam'\r\n *       - $ref: '#/components/parameters/SortParam'\r\n *       - $ref: '#/components/parameters/ApiVersionHeader'\r\n *       - in: query\r\n *         name: filter[role][eq]\r\n *         schema:\r\n *           type: string\r\n *           enum: [USER, ADMIN]\r\n *         description: Filter by role\r\n *       - in: query\r\n *         name: filter[email][contains]\r\n *         schema:\r\n *           type: string\r\n *         description: Filter by email (case-insensitive)\r\n *     responses:\r\n *       200:\r\n *         description: Successful response\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 data:\r\n *                   type: array\r\n *                   items:\r\n *                     $ref: '#/components/schemas/User'\r\n *                 _links:\r\n *                   type: object\r\n *                   additionalProperties:\r\n *                     $ref: '#/components/schemas/HATEOASLink'\r\n *                 _meta:\r\n *                   $ref: '#/components/schemas/PaginationMeta'\r\n *       401:\r\n *         $ref: '#/components/responses/UnauthorizedError'\r\n *       403:\r\n *         $ref: '#/components/responses/ForbiddenError'\r\n */\r\n// @ts-expect-error TS7030 - TypeScript doesn't recognize res.json() and next() as terminal statements\r\nrouter.get('/', async (req: Request, res: Response, next: NextFunction) => {\r\n  try {\r\n    const db = container.resolve(DatabaseService);\r\n    const authz = container.resolve<AuthorizationService>('AuthorizationService');\r\n\r\n    // Check authorization\r\n    const userId = (req as any).user?.id;\r\n    if (!userId) {\r\n      return res.status(401).json({ error: 'Unauthorized' });\r\n    }\r\n\r\n    const hasPermission = await authz.hasPermission(userId, 'users:read');\r\n    if (!hasPermission) {\r\n      return res.status(403).json({ error: 'Forbidden' });\r\n    }\r\n\r\n    // Parse query parameters\r\n    const { page, pageSize, sort } = getPaginationParams(req);\r\n    const filters = parseFilters(req.query);\r\n    const sorting = parseSorting(sort);\r\n    const { skip, take } = getSkipTake(page, pageSize);\r\n\r\n    // Build Prisma where clause\r\n    const where = filtersToPrismaWhere(filters);\r\n\r\n    // Build Prisma orderBy clause\r\n    const orderBy = sortToPrismaOrderBy(\r\n      sorting.length > 0 ? sorting : [{ field: 'createdAt', order: 'desc' }]\r\n    );\r\n\r\n    // Fetch users with pagination\r\n    const [users, total] = await Promise.all([\r\n      db.user.findMany({\r\n        where,\r\n        skip,\r\n        take,\r\n        orderBy,\r\n        select: {\r\n          id: true,\r\n          email: true,\r\n          name: true,\r\n          role: true,\r\n          createdAt: true,\r\n          updatedAt: true,\r\n          lastLoginAt: true,\r\n        },\r\n      }),\r\n      db.user.count({ where }),\r\n    ]);\r\n\r\n    // Add HATEOAS links to each user\r\n    const usersWithLinks = users.map((user) =>\r\n      createResourceLinks(req, user.id, '/api/users').build(user)\r\n    );\r\n\r\n    // Build paginated response with collection links\r\n    const response = createCollectionLinks(req, '/api/users', page, pageSize, total).buildPaginated(\r\n      usersWithLinks,\r\n      total,\r\n      page,\r\n      pageSize\r\n    );\r\n\r\n    res.json(response);\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n});\r\n\r\n/**\r\n * @swagger\r\n * /api/users/{id}:\r\n *   get:\r\n *     summary: Get user by ID\r\n *     description: Retrieve detailed information about a specific user\r\n *     tags: [Users]\r\n *     security:\r\n *       - bearerAuth: []\r\n *     parameters:\r\n *       - in: path\r\n *         name: id\r\n *         required: true\r\n *         schema:\r\n *           type: string\r\n *         description: User ID\r\n *       - $ref: '#/components/parameters/ApiVersionHeader'\r\n *     responses:\r\n *       200:\r\n *         description: Successful response\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 data:\r\n *                   $ref: '#/components/schemas/User'\r\n *                 _links:\r\n *                   type: object\r\n *                   additionalProperties:\r\n *                     $ref: '#/components/schemas/HATEOASLink'\r\n *       401:\r\n *         $ref: '#/components/responses/UnauthorizedError'\r\n *       403:\r\n *         $ref: '#/components/responses/ForbiddenError'\r\n *       404:\r\n *         $ref: '#/components/responses/NotFoundError'\r\n */\r\nrouter.get('/:id', async (req: Request, res: Response, next: NextFunction) => {\r\n  try {\r\n    const db = container.resolve(DatabaseService);\r\n    const authz = container.resolve<AuthorizationService>('AuthorizationService');\r\n\r\n    const userId = (req as any).user?.id;\r\n    if (!userId) {\r\n      res.status(401).json({ error: 'Unauthorized' });\r\n      return;\r\n    }\r\n\r\n    const hasPermission = await authz.hasPermission(userId, 'users:read');\r\n    if (!hasPermission) {\r\n      res.status(403).json({ error: 'Forbidden' });\r\n      return;\r\n    }\r\n\r\n    const user = await db.user.findUnique({\r\n      where: { id: req.params['id'] },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        role: true,\r\n        createdAt: true,\r\n        updatedAt: true,\r\n        lastLoginAt: true,\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      res.status(404).json({\r\n        error: 'Not Found',\r\n        message: 'User not found',\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Build HATEOAS response\r\n    const response = createResourceLinks(req, user.id, '/api/users').build(user);\r\n\r\n    res.json(response);\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n});\r\n\r\n/**\r\n * @swagger\r\n * components:\r\n *   schemas:\r\n *     User:\r\n *       type: object\r\n *       properties:\r\n *         id:\r\n *           type: string\r\n *           description: User unique identifier\r\n *         email:\r\n *           type: string\r\n *           format: email\r\n *           description: User email address\r\n *         name:\r\n *           type: string\r\n *           description: User full name\r\n *         role:\r\n *           type: string\r\n *           enum: [USER, ADMIN]\r\n *           description: User role\r\n *         createdAt:\r\n *           type: string\r\n *           format: date-time\r\n *           description: Account creation timestamp\r\n *         updatedAt:\r\n *           type: string\r\n *           format: date-time\r\n *           description: Last update timestamp\r\n *         lastLoginAt:\r\n *           type: string\r\n *           format: date-time\r\n *           description: Last login timestamp\r\n */\r\n\r\nexport const usersRouter = router;\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\routes\\users.routes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\security\\interfaces.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\audit\\audit-log.service.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 101,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 101,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2534, 2537], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2534, 2537], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 70,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 70,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1882, 1931], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Development audit log output (replace with proper logging in production)"
          }
        ]
      }
    ],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { injectable } from 'tsyringe';\n\nexport interface AuditLogEntry {\n  timestamp: Date;\n  userId?: string;\n  action: string;\n  resource: string;\n  resourceId?: string;\n  ipAddress?: string;\n  userAgent?: string;\n  success: boolean;\n  errorMessage?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport enum AuditAction {\n  // Authentication\n  LOGIN = 'auth.login',\n  LOGOUT = 'auth.logout',\n  LOGIN_FAILED = 'auth.login_failed',\n  TOKEN_REFRESH = 'auth.token_refresh',\n  PASSWORD_CHANGE = 'auth.password_change',\n  PASSWORD_RESET = 'auth.password_reset',\n\n  // Authorization\n  ACCESS_GRANTED = 'authz.access_granted',\n  ACCESS_DENIED = 'authz.access_denied',\n  ROLE_ASSIGNED = 'authz.role_assigned',\n  ROLE_REVOKED = 'authz.role_revoked',\n  PERMISSION_GRANTED = 'authz.permission_granted',\n  PERMISSION_REVOKED = 'authz.permission_revoked',\n\n  // Data operations\n  CREATE = 'data.create',\n  READ = 'data.read',\n  UPDATE = 'data.update',\n  DELETE = 'data.delete',\n\n  // Security events\n  ENCRYPTION_KEY_ROTATION = 'security.key_rotation',\n  SECRET_ACCESS = 'security.secret_access',\n  SUSPICIOUS_ACTIVITY = 'security.suspicious_activity',\n}\n\n/**\n * Audit logging service for security events\n * In production, this would write to a secure audit log storage\n */\n@injectable()\nexport class AuditLogService {\n  private logs: AuditLogEntry[] = [];\n\n  /**\n   * Log security event\n   */\n  async log(entry: Omit<AuditLogEntry, 'timestamp'>): Promise<void> {\n    const logEntry: AuditLogEntry = {\n      ...entry,\n      timestamp: new Date(),\n    };\n\n    this.logs.push(logEntry);\n\n    // In production:\n    // - Write to database with retention policy\n    // - Send to SIEM system\n    // - Trigger alerts for critical events\n    // - Ensure immutability of logs\n    // eslint-disable-next-line no-console -- Development audit log output (replace with proper logging in production)\n    console.log('[AUDIT]', JSON.stringify(logEntry));\n  }\n\n  /**\n   * Log authentication event\n   */\n  async logAuth(params: {\n    userId?: string;\n    action: AuditAction;\n    success: boolean;\n    ipAddress?: string;\n    userAgent?: string;\n    errorMessage?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<void> {\n    await this.log({\n      ...params,\n      resource: 'authentication',\n    });\n  }\n\n  /**\n   * Log authorization event\n   */\n  async logAuthz(params: {\n    userId: string;\n    action: AuditAction;\n    resource: string;\n    resourceId?: string;\n    success: boolean;\n    errorMessage?: string;\n    metadata?: Record<string, any>;\n  }): Promise<void> {\n    await this.log({\n      ...params,\n    });\n  }\n\n  /**\n   * Log data access event\n   */\n  async logDataAccess(params: {\n    userId: string;\n    action: AuditAction;\n    resource: string;\n    resourceId?: string;\n    success: boolean;\n    metadata?: Record<string, unknown>;\n  }): Promise<void> {\n    await this.log({\n      ...params,\n    });\n  }\n\n  /**\n   * Log security event\n   */\n  async logSecurityEvent(params: {\n    userId?: string;\n    action: AuditAction;\n    resource: string;\n    success: boolean;\n    errorMessage?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<void> {\n    await this.log({\n      ...params,\n    });\n  }\n\n  /**\n   * Clear in-memory logs (test helper)\n   */\n  clear(): void {\n    this.logs.length = 0;\n  }\n\n  /**\n   * Get audit logs (with pagination and filtering)\n   * In production, this would query from persistent storage\n   */\n  async getLogs(filter?: {\n    userId?: string;\n    action?: string;\n    resource?: string;\n    startDate?: Date;\n    endDate?: Date;\n    limit?: number;\n  }): Promise<AuditLogEntry[]> {\n    let filtered = this.logs;\n\n    if (filter?.userId) {\n      filtered = filtered.filter((log) => log.userId === filter.userId);\n    }\n\n    if (filter?.action) {\n      filtered = filtered.filter((log) => log.action === filter.action);\n    }\n\n    if (filter?.resource) {\n      filtered = filtered.filter((log) => log.resource === filter.resource);\n    }\n\n    if (filter?.startDate) {\n      const startDate = filter.startDate;\n      filtered = filtered.filter((log) => log.timestamp >= startDate);\n    }\n\n    if (filter?.endDate) {\n      const endDate = filter.endDate;\n      filtered = filtered.filter((log) => log.timestamp <= endDate);\n    }\n\n    if (filter?.limit) {\n      filtered = filtered.slice(0, filter.limit);\n    }\n\n    return filtered;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\authorization.service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\encryption.service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\jwt.service.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'_error' is defined but never used.",
        "line": 59,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 59,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'_error' is defined but never used.",
        "line": 71,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 71,
        "endColumn": 20
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 104,
        "column": 21,
        "nodeType": "MemberExpression",
        "endLine": 104,
        "endColumn": 38
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { TokenPayload, TokenResult } from '@repo/types';\nimport jwt from 'jsonwebtoken';\nimport { injectable } from 'tsyringe';\n\n@injectable()\nexport class JwtService {\n  private readonly accessTokenSecret: string;\n  private readonly refreshTokenSecret: string;\n  private readonly accessTokenExpiry: string;\n  private readonly refreshTokenExpiry: string;\n\n  constructor() {\n    this.accessTokenSecret = process.env['JWT_ACCESS_SECRET'] || 'access-secret-change-me';\n    this.refreshTokenSecret = process.env['JWT_REFRESH_SECRET'] || 'refresh-secret-change-me';\n    this.accessTokenExpiry = process.env['JWT_ACCESS_EXPIRY'] || '15m';\n    this.refreshTokenExpiry = process.env['JWT_REFRESH_EXPIRY'] || '7d';\n  }\n\n  /**\n   * Generate access token\n   */\n  generateAccessToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    return jwt.sign(payload, this.accessTokenSecret, {\n      expiresIn: this.accessTokenExpiry,\n    } as jwt.SignOptions);\n  }\n\n  /**\n   * Generate refresh token\n   */\n  generateRefreshToken(userId: string): string {\n    return jwt.sign({ userId }, this.refreshTokenSecret, {\n      expiresIn: this.refreshTokenExpiry,\n    } as jwt.SignOptions);\n  }\n\n  /**\n   * Generate both access and refresh tokens\n   */\n  generateTokens(payload: Omit<TokenPayload, 'iat' | 'exp'>): TokenResult {\n    const accessToken = this.generateAccessToken(payload);\n    const refreshToken = this.generateRefreshToken(payload['userId']);\n\n    return {\n      accessToken,\n      refreshToken,\n      expiresIn: this.parseExpiry(this.accessTokenExpiry),\n      tokenType: 'Bearer',\n    };\n  }\n\n  /**\n   * Validate access token\n   */\n  async validateAccessToken(token: string): Promise<TokenPayload> {\n    try {\n      const decoded = jwt.verify(token, this.accessTokenSecret) as TokenPayload;\n      return decoded;\n    } catch (_error) {\n      throw new Error('Invalid or expired access token');\n    }\n  }\n\n  /**\n   * Validate refresh token\n   */\n  async validateRefreshToken(token: string): Promise<{ userId: string }> {\n    try {\n      const decoded = jwt.verify(token, this.refreshTokenSecret) as { userId: string };\n      return decoded;\n    } catch (_error) {\n      throw new Error('Invalid or expired refresh token');\n    }\n  }\n\n  /**\n   * Decode token without validation (for inspection)\n   */\n  decodeToken(token: string): TokenPayload | null {\n    try {\n      return jwt.decode(token) as TokenPayload;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Parse expiry string to seconds\n   */\n  private parseExpiry(expiry: string): number {\n    const match = expiry.match(/^(\\d+)([smhd])$/);\n    if (!match || !match[1] || !match[2]) return 900; // default 15 minutes\n\n    const value = parseInt(match[1], 10);\n    const unit = match[2];\n\n    const multipliers: Record<string, number> = {\n      s: 1,\n      m: 60,\n      h: 3600,\n      d: 86400,\n    };\n\n    return value * (multipliers[unit] || 60);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\policy-engine.service.ts",
    "messages": [
      {
        "ruleId": null,
        "message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').",
        "line": 254,
        "column": 3,
        "severity": 1,
        "nodeType": null,
        "fix": { "range": [6887, 6949], "text": " " }
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 258,
        "column": 6,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 258,
        "endColumn": 9,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7063, 7066], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7063, 7066], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 260,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 260,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7187, 7190], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7187, 7190], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 275,
        "column": 16,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 275,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7640, 7643], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7640, 7643], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 280,
        "column": 17,
        "nodeType": "MemberExpression",
        "endLine": 280,
        "endColumn": 27,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 294,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 294,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8154, 8157], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8154, 8157], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 294,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 294,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8199, 8202], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8199, 8202], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-non-literal-regexp",
        "severity": 1,
        "message": "Found non-literal argument to RegExp Constructor",
        "line": 333,
        "column": 27,
        "nodeType": "NewExpression",
        "endLine": 333,
        "endColumn": 47,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import {\n  ComparisonOperator,\n  Condition,\n  IPolicyEngine,\n  LogicalCondition,\n  LogicalOperator,\n  Policy,\n  PolicyContext,\n  PolicyEffect,\n  PolicyEvaluationResult,\n  PolicyRule,\n} from '@repo/types';\nimport { injectable } from 'tsyringe';\n\n/**\n * Policy evaluation engine for ABAC\n * Evaluates policies and conditions against a given context\n */\n@injectable()\nexport class PolicyEngine implements IPolicyEngine {\n  /**\n   * Evaluate all applicable policies for a given context\n   * Uses deny-overrides strategy: if any policy denies, access is denied\n   * @deprecated Use evaluatePolicies instead - this method requires policies to be passed in\n   */\n  async evaluate(_context: PolicyContext): Promise<PolicyEvaluationResult> {\n    throw new Error(\n      'evaluate method requires policies to be passed in - use evaluatePolicies instead'\n    );\n  }\n\n  /**\n   * Evaluate multiple policies with deny-overrides strategy\n   */\n  async evaluatePolicies(\n    policies: Policy[],\n    context: PolicyContext\n  ): Promise<PolicyEvaluationResult> {\n    const deniedRules: string[] = [];\n    const allowedRules: string[] = [];\n\n    // Sort policies by priority if available\n    const sortedPolicies = [...policies].filter((p) => p.enabled);\n\n    for (const policy of sortedPolicies) {\n      const result = await this.evaluatePolicy(policy, context);\n\n      if (result.effect === PolicyEffect.DENY) {\n        deniedRules.push(...result.matchedRules);\n      } else if (result.effect === PolicyEffect.ALLOW) {\n        allowedRules.push(...result.matchedRules);\n      }\n    }\n\n    // Deny-overrides: if any rule denies, access is denied\n    if (deniedRules.length > 0) {\n      return {\n        effect: PolicyEffect.DENY,\n        matchedRules: deniedRules,\n        reason: `Access denied by rules: ${deniedRules.join(', ')}`,\n      };\n    }\n\n    // If at least one rule allows, access is granted\n    if (allowedRules.length > 0) {\n      return {\n        effect: PolicyEffect.ALLOW,\n        matchedRules: allowedRules,\n        reason: `Access granted by rules: ${allowedRules.join(', ')}`,\n      };\n    }\n\n    // No rules matched - default deny\n    return {\n      effect: PolicyEffect.DENY,\n      matchedRules: [],\n      reason: 'No matching policy rules found (default deny)',\n    };\n  }\n\n  /**\n   * Evaluate a single policy\n   */\n  async evaluatePolicy(policy: Policy, context: PolicyContext): Promise<PolicyEvaluationResult> {\n    if (!policy.enabled) {\n      return {\n        effect: PolicyEffect.DENY,\n        matchedRules: [],\n        reason: 'Policy is disabled',\n      };\n    }\n\n    const matchedRules: string[] = [];\n    const deniedRules: string[] = [];\n    const allowedRules: string[] = [];\n\n    // Sort rules by priority (higher priority first)\n    const sortedRules = [...policy.rules].sort((a, b) => {\n      const priorityA = a.priority ?? 0;\n      const priorityB = b.priority ?? 0;\n      return priorityB - priorityA;\n    });\n\n    for (const rule of sortedRules) {\n      const matches = await this.evaluateRule(rule, context);\n\n      if (matches) {\n        matchedRules.push(rule.id);\n\n        if (rule.effect === PolicyEffect.DENY) {\n          deniedRules.push(rule.id);\n        } else {\n          allowedRules.push(rule.id);\n        }\n      }\n    }\n\n    // Deny-overrides within policy\n    if (deniedRules.length > 0) {\n      return {\n        effect: PolicyEffect.DENY,\n        matchedRules: deniedRules,\n        reason: `Denied by rules: ${deniedRules.join(', ')}`,\n      };\n    }\n\n    if (allowedRules.length > 0) {\n      return {\n        effect: PolicyEffect.ALLOW,\n        matchedRules: allowedRules,\n        reason: `Allowed by rules: ${allowedRules.join(', ')}`,\n      };\n    }\n\n    // No rules matched in this policy\n    return {\n      effect: PolicyEffect.DENY,\n      matchedRules: [],\n      reason: 'No matching rules in policy',\n    };\n  }\n\n  /**\n   * Evaluate a single rule\n   */\n  async evaluateRule(rule: PolicyRule, context: PolicyContext): Promise<boolean> {\n    return this.evaluateConditions(rule.conditions, context);\n  }\n\n  /**\n   * Evaluate conditions (logical combination)\n   */\n  async evaluateConditions(conditions: LogicalCondition, context: PolicyContext): Promise<boolean> {\n    switch (conditions.operator) {\n      case LogicalOperator.AND:\n        return this.evaluateAnd(conditions.conditions, context);\n\n      case LogicalOperator.OR:\n        return this.evaluateOr(conditions.conditions, context);\n\n      case LogicalOperator.NOT:\n        return this.evaluateNot(conditions.conditions, context);\n\n      default:\n        throw new Error(`Unsupported logical operator: ${conditions.operator}`);\n    }\n  }\n\n  /**\n   * Evaluate AND conditions (all must be true)\n   */\n  private async evaluateAnd(\n    conditions: (Condition | LogicalCondition)[],\n    context: PolicyContext\n  ): Promise<boolean> {\n    for (const condition of conditions) {\n      const result = await this.evaluateCondition(condition, context);\n      if (!result) {\n        return false;\n      }\n    }\n    return conditions.length > 0;\n  }\n\n  /**\n   * Evaluate OR conditions (at least one must be true)\n   */\n  private async evaluateOr(\n    conditions: (Condition | LogicalCondition)[],\n    context: PolicyContext\n  ): Promise<boolean> {\n    for (const condition of conditions) {\n      const result = await this.evaluateCondition(condition, context);\n      if (result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Evaluate NOT conditions (negation)\n   */\n  private async evaluateNot(\n    conditions: (Condition | LogicalCondition)[],\n    context: PolicyContext\n  ): Promise<boolean> {\n    if (conditions.length === 0) {\n      return false;\n    }\n\n    const firstCondition = conditions[0];\n    if (!firstCondition) {\n      return false;\n    }\n\n    const result = await this.evaluateCondition(firstCondition, context);\n    return !result;\n  }\n\n  /**\n   * Evaluate a single condition or logical condition\n   */\n  private async evaluateCondition(\n    condition: Condition | LogicalCondition,\n    context: PolicyContext\n  ): Promise<boolean> {\n    // Check if it's a logical condition\n    if ('operator' in condition && 'conditions' in condition) {\n      return this.evaluateConditions(condition as LogicalCondition, context);\n    }\n\n    // Otherwise, it's a simple condition\n    return this.evaluateSimpleCondition(condition as Condition, context);\n  }\n\n  /**\n   * Evaluate a simple condition\n   */\n  private async evaluateSimpleCondition(\n    condition: Condition,\n    context: PolicyContext\n  ): Promise<boolean> {\n    const actualValue = this.extractAttributeValue(condition.attribute, context);\n    const expectedValue = condition.value;\n\n    return this.compareValues(actualValue, condition.operator, expectedValue);\n  }\n\n  /**\n   * Extract attribute value from context\n   * Note: Uses 'any' for generic ABAC attribute handling across dynamic contexts\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private extractAttributeValue(\n    attribute: { source: string; key: string },\n    context: PolicyContext\n  ): any {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const sourceMap: Record<string, Record<string, any>> = {\n      user: context.user,\n      resource: context.resource,\n      environment: context.environment,\n      action: { value: context.action },\n    };\n\n    const source = sourceMap[attribute.source];\n    if (!source) {\n      return undefined;\n    }\n\n    // Support nested keys with dot notation (e.g., \"user.department\")\n    const keys = attribute.key.split('.');\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let value: any = source;\n\n    for (const key of keys) {\n      if (value && typeof value === 'object') {\n        // eslint-disable-next-line security/detect-object-injection\n        value = value[key];\n      } else {\n        return undefined;\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * Compare values using the specified operator\n   * Note: Uses 'any' for generic ABAC value comparison across dynamic attribute types\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private compareValues(actual: any, operator: ComparisonOperator, expected: any): boolean {\n    switch (operator) {\n      case ComparisonOperator.EQUALS:\n        return actual === expected;\n\n      case ComparisonOperator.NOT_EQUALS:\n        return actual !== expected;\n\n      case ComparisonOperator.GREATER_THAN:\n        return actual > expected;\n\n      case ComparisonOperator.GREATER_THAN_OR_EQUAL:\n        return actual >= expected;\n\n      case ComparisonOperator.LESS_THAN:\n        return actual < expected;\n\n      case ComparisonOperator.LESS_THAN_OR_EQUAL:\n        return actual <= expected;\n\n      case ComparisonOperator.IN:\n        return Array.isArray(expected) && expected.includes(actual);\n\n      case ComparisonOperator.NOT_IN:\n        return Array.isArray(expected) && !expected.includes(actual);\n\n      case ComparisonOperator.CONTAINS:\n        if (typeof actual === 'string' && typeof expected === 'string') {\n          return actual.includes(expected);\n        }\n        if (Array.isArray(actual)) {\n          return actual.includes(expected);\n        }\n        return false;\n\n      case ComparisonOperator.MATCHES:\n        if (typeof actual === 'string' && typeof expected === 'string') {\n          try {\n            // eslint-disable-next-line security/detect-non-literal-regexp\n            const regex = new RegExp(expected);\n            return regex.test(actual);\n          } catch {\n            return false;\n          }\n        }\n        return false;\n\n      default:\n        throw new Error(`Unsupported comparison operator: ${operator}`);\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\policy-store.service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\cache.service.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 10,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 10,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 14,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 14,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 19,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 19,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 25,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 25,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 29,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 29,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 33,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 33,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 37,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 37,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 41,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 41,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 46,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 46,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 50,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 50,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 55,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 55,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 66,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 66,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1300, 1303], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1300, 1303], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 80,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 80,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1776, 1779], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1776, 1779], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 233,
        "column": 16,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 233,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5754, 5757], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5754, 5757], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import Redis from 'ioredis';\r\nimport { inject, singleton } from 'tsyringe';\r\n\r\nimport { LoggerService } from './logger.service';\r\n\r\n// Minimal in-memory mock implementing the Redis subset used in tests\r\nclass MockRedis {\r\n  private store = new Map<string, string>();\r\n\r\n  async get(key: string) {\r\n    return this.store.get(key) ?? null;\r\n  }\r\n\r\n  async set(key: string, value: string) {\r\n    this.store.set(key, value);\r\n    return 'OK';\r\n  }\r\n\r\n  async setex(key: string, _ttl: number, value: string) {\r\n    this.store.set(key, value);\r\n    // TTL ignored for mock\r\n    return 'OK';\r\n  }\r\n\r\n  async del(key: string) {\r\n    return this.store.delete(key) ? 1 : 0;\r\n  }\r\n\r\n  async exists(key: string) {\r\n    return this.store.has(key) ? 1 : 0;\r\n  }\r\n\r\n  async expire(_key: string, _ttl: number) {\r\n    return 1;\r\n  }\r\n\r\n  async mget(...keys: string[]) {\r\n    return keys.map((k) => this.store.get(k) ?? null);\r\n  }\r\n\r\n  async flushdb() {\r\n    this.store.clear();\r\n    return 'OK';\r\n  }\r\n\r\n  async ping() {\r\n    return 'PONG';\r\n  }\r\n\r\n  async quit() {\r\n    return 'OK';\r\n  }\r\n\r\n  // Event handlers compatibility stubs\r\n  on() {\r\n    // no-op for mock\r\n  }\r\n}\r\n\r\n/**\r\n * Redis caching service with DI\r\n * Implements cache-aside pattern\r\n */\r\n@singleton()\r\nexport class CacheService {\r\n  private client: any;\r\n\r\n  constructor(@inject(LoggerService) private logger: LoggerService) {\r\n    const disableExternal =\r\n      process.env['TEST_EXTERNAL_SERVICES'] === 'false' || process.env['REDIS_MOCK'] === 'true';\r\n\r\n    if (disableExternal) {\r\n      // Use in-memory mock to avoid long reconnect loops in tests\r\n      this.client = new MockRedis();\r\n      this.logger.info('Using MockRedis for tests');\r\n      return;\r\n    }\r\n\r\n    // Default Redis options\r\n    const defaultOptions: any = {\r\n      retryStrategy: (times: number) => {\r\n        const delay = Math.min(times * 50, 2000);\r\n        return delay;\r\n      },\r\n      maxRetriesPerRequest: 3,\r\n      enableOfflineQueue: true,\r\n      connectTimeout: 10000,\r\n    };\r\n\r\n    // Shorten retries / disable offline queue during test runs to fail fast\r\n    if (process.env['NODE_ENV'] === 'test') {\r\n      defaultOptions.maxRetriesPerRequest = 1;\r\n      defaultOptions.retryStrategy = () => null; // stop retrying\r\n      defaultOptions.enableOfflineQueue = false;\r\n      defaultOptions.connectTimeout = 1000;\r\n    }\r\n\r\n    this.client = new Redis(process.env['REDIS_URL'] || 'redis://localhost:6379', defaultOptions);\r\n\r\n    // Attach event handlers only if using real Redis\r\n    (this.client as Redis).on('connect', () => {\r\n      this.logger.info('Redis client connected');\r\n    });\r\n\r\n    (this.client as Redis).on('error', (err: Error) => {\r\n      this.logger.error('Redis client error', err);\r\n    });\r\n\r\n    (this.client as Redis).on('reconnecting', () => {\r\n      this.logger.warn('Redis client reconnecting');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get value from cache\r\n   */\r\n  async get<T>(key: string): Promise<T | null> {\r\n    try {\r\n      const value = await this.client.get(key);\r\n      if (!value) return null;\r\n      return JSON.parse(value) as T;\r\n    } catch (error) {\r\n      this.logger.error(`Cache get error for key: ${key}`, error as Error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set value in cache with optional TTL (seconds)\r\n   */\r\n  async set(key: string, value: unknown, ttl?: number): Promise<boolean> {\r\n    try {\r\n      const serialized = JSON.stringify(value);\r\n      if (ttl) {\r\n        await this.client.setex(key, ttl, serialized);\r\n      } else {\r\n        await this.client.set(key, serialized);\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error(`Cache set error for key: ${key}`, error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete value from cache\r\n   */\r\n  async delete(key: string): Promise<boolean> {\r\n    try {\r\n      await this.client.del(key);\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error(`Cache delete error for key: ${key}`, error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if key exists\r\n   */\r\n  async exists(key: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.client.exists(key);\r\n      return result === 1;\r\n    } catch (error) {\r\n      this.logger.error(`Cache exists error for key: ${key}`, error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set key expiration (seconds)\r\n   */\r\n  async expire(key: string, ttl: number): Promise<boolean> {\r\n    try {\r\n      await this.client.expire(key, ttl);\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error(`Cache expire error for key: ${key}`, error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get multiple keys\r\n   */\r\n  async mget<T>(keys: string[]): Promise<Array<T | null>> {\r\n    try {\r\n      const values = await this.client.mget(...keys);\r\n      return values.map((v: string | null) => (v ? (JSON.parse(v) as T) : null));\r\n    } catch (error) {\r\n      this.logger.error(`Cache mget error for keys: ${keys.join(', ')}`, error as Error);\r\n      return keys.map(() => null);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Flush all cache\r\n   */\r\n  async flush(): Promise<boolean> {\r\n    try {\r\n      await this.client.flushdb();\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error('Cache flush error', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check cache health\r\n   */\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const result = await this.client.ping();\r\n      return result === 'PONG';\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect from Redis\r\n   */\r\n  async disconnect(): Promise<void> {\r\n    await this.client.quit();\r\n  }\r\n\r\n  /**\r\n   * Get Redis client instance\r\n   */\r\n  getClient(): any {\r\n    return this.client;\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\database.service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\logger.service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\notification-provider.factory.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 64,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 64,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [2302, 2353], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "Startup information logging" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 66,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 66,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [2434, 2481], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "Startup information logging" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 68,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 68,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [2562, 2624], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "Startup information logging" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\notification.service.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 25,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 25,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [632, 635], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [632, 635], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 47,
        "column": 47,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 47,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1347, 1350], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1347, 1350], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 69,
        "column": 73,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 69,
        "endColumn": 76,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2052, 2055], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2052, 2055], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 97,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 97,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2886, 2889], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2886, 2889], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\r\n  EmailOptions,\r\n  IEmailProvider,\r\n  IPushNotificationProvider,\r\n  ISmsProvider,\r\n  PushNotificationOptions,\r\n  SmsOptions,\r\n} from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\nimport { LoggerService } from '../logger.service';\r\n\r\n/**\r\n * Main notification service that delegates to specific providers\r\n */\r\n@injectable()\r\nexport class NotificationService {\r\n  constructor(\r\n    private logger: LoggerService,\r\n    private emailProvider: IEmailProvider,\r\n    private smsProvider: ISmsProvider,\r\n    private pushProvider: IPushNotificationProvider\r\n  ) {}\r\n\r\n  async sendEmail(options: EmailOptions): Promise<any> {\r\n    try {\r\n      this.logger.info('Sending email', { to: options.to, subject: options.subject });\r\n      const result = await this.emailProvider.send(options);\r\n\r\n      if (result.success) {\r\n        this.logger.info('Email sent successfully', { messageId: result.messageId });\r\n      } else {\r\n        this.logger.error('Email send failed', new Error(result.error || 'Unknown error'));\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      this.logger.error('Email send error', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n        notificationId: Date.now().toString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  async sendSms(options: SmsOptions): Promise<any> {\r\n    try {\r\n      this.logger.info('Sending SMS', { to: options.to });\r\n      const result = await this.smsProvider.send(options);\r\n\r\n      if (result.success) {\r\n        this.logger.info('SMS sent successfully', { messageId: result.messageId });\r\n      } else {\r\n        this.logger.error('SMS send failed', new Error(result.error || 'Unknown error'));\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      this.logger.error('SMS send error', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n        notificationId: Date.now().toString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  async sendPushNotification(options: PushNotificationOptions): Promise<any> {\r\n    try {\r\n      this.logger.info('Sending push notification', {\r\n        userId: options.userId,\r\n        title: options.title,\r\n      });\r\n      const result = await this.pushProvider.send(options);\r\n\r\n      if (result.success) {\r\n        this.logger.info('Push notification sent successfully', { messageId: result.messageId });\r\n      } else {\r\n        this.logger.error(\r\n          'Push notification send failed',\r\n          new Error(result.error || 'Unknown error')\r\n        );\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      this.logger.error('Push notification send error', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n        notificationId: Date.now().toString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  async sendBulkEmail(emails: EmailOptions[]): Promise<any[]> {\r\n    this.logger.info('Sending bulk emails', { count: emails.length });\r\n\r\n    const results = await Promise.allSettled(emails.map((email) => this.sendEmail(email)));\r\n\r\n    return results.map((result) => {\r\n      if (result.status === 'fulfilled') {\r\n        return result.value;\r\n      } else {\r\n        return {\r\n          success: false,\r\n          error: result.reason?.message || 'Unknown error',\r\n          notificationId: Date.now().toString(),\r\n        };\r\n      }\r\n    });\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const [emailHealth, smsHealth, pushHealth] = await Promise.all([\r\n        this.emailProvider.healthCheck(),\r\n        this.smsProvider.healthCheck(),\r\n        this.pushProvider.healthCheck(),\r\n      ]);\r\n\r\n      return emailHealth && smsHealth && pushHealth;\r\n    } catch (error) {\r\n      this.logger.error('Notification service health check failed', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\console-email.provider.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 24,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 24,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [810, 849], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 26,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 26,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [960, 991], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 28,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 28,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1102, 1162], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 30,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 30,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1273, 1314], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 32,
        "column": 21,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 32,
        "endColumn": 32,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 34,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 34,
        "endColumn": 33,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 36,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 36,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1744, 1802], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 38,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 38,
        "endColumn": 34,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 40,
        "column": 30,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 40,
        "endColumn": 41,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 42,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 42,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [2299, 2336], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development email provider"
          }
        ]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\console-push.provider.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 26,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 26,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [843, 886], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 28,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 28,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1009, 1049], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 30,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 30,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1172, 1209], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 32,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 32,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1332, 1367], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 34,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 34,
        "endColumn": 34,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 36,
        "column": 24,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 36,
        "endColumn": 35,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 38,
        "column": 24,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 38,
        "endColumn": 35,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 40,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 40,
        "endColumn": 34,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 42,
        "column": 27,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 42,
        "endColumn": 38,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 44,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 44,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [2410, 2452], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development push notification provider"
          }
        ]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\console-sms.provider.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 22,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 22,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [721, 758], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development SMS provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 24,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 24,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [867, 898], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development SMS provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 26,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 26,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1007, 1059], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development SMS provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 28,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 28,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1168, 1203], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development SMS provider"
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 30,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 30,
        "endColumn": 16,
        "suggestions": [
          {
            "fix": { "range": [1312, 1348], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Intentional console output for development SMS provider"
          }
        ]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\fcm-push.provider.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/ban-ts-comment",
        "severity": 2,
        "message": "Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.",
        "line": 48,
        "column": 7,
        "nodeType": "Line",
        "messageId": "tsIgnoreInsteadOfExpectError",
        "endLine": 48,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "replaceTsIgnoreWithTsExpectError",
            "fix": {
              "range": [1632, 1685],
              "text": "// @ts-expect-error - Used when firebase-admin is installed"
            },
            "desc": "Replace \"@ts-ignore\" with \"@ts-expect-error\"."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'message' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 49,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 49,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/ban-ts-comment",
        "severity": 2,
        "message": "Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.",
        "line": 103,
        "column": 3,
        "nodeType": "Line",
        "messageId": "tsIgnoreInsteadOfExpectError",
        "endLine": 103,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "replaceTsIgnoreWithTsExpectError",
            "fix": {
              "range": [3125, 3178],
              "text": "// @ts-expect-error - Placeholder for future implementation"
            },
            "desc": "Replace \"@ts-ignore\" with \"@ts-expect-error\"."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'userId' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 104,
        "column": 33,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 104,
        "endColumn": 39
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\r\n  IPushNotificationProvider,\r\n  NotificationResult,\r\n  PushNotificationOptions,\r\n} from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\nimport { LoggerService } from '../../logger.service';\r\n\r\n/**\r\n * Firebase Cloud Messaging (FCM) push notification provider\r\n * Requires FIREBASE_PROJECT_ID and FIREBASE_SERVICE_ACCOUNT_KEY environment variables\r\n */\r\n@injectable()\r\nexport class FcmPushProvider implements IPushNotificationProvider {\r\n  private projectId: string;\r\n  private serviceAccountKey: string;\r\n\r\n  constructor(private logger: LoggerService) {\r\n    this.projectId = process.env['FIREBASE_PROJECT_ID'] || '';\r\n    this.serviceAccountKey = process.env['FIREBASE_SERVICE_ACCOUNT_KEY'] || '';\r\n\r\n    if (!this.projectId || !this.serviceAccountKey) {\r\n      this.logger.warn('Firebase credentials not configured. Push notifications will fail.');\r\n    }\r\n  }\r\n\r\n  async send(options: PushNotificationOptions): Promise<NotificationResult> {\r\n    try {\r\n      if (!this.projectId) {\r\n        throw new Error('Firebase project ID not configured');\r\n      }\r\n\r\n      // Firebase Admin SDK implementation\r\n      // Note: Install firebase-admin package when ready to use\r\n      // const admin = require('firebase-admin');\r\n\r\n      // if (!admin.apps.length) {\r\n      //   admin.initializeApp({\r\n      //     credential: admin.credential.cert(JSON.parse(this.serviceAccountKey)),\r\n      //     projectId: this.projectId,\r\n      //   });\r\n      // }\r\n\r\n      // Get user's FCM token from database (would need to be stored during login)\r\n      // const fcmToken = await this.getUserFcmToken(options.userId);\r\n\r\n      // @ts-ignore - Used when firebase-admin is installed\r\n      const message = {\r\n        notification: {\r\n          title: options.title,\r\n          body: options.body,\r\n        },\r\n        data: options.data,\r\n        // token: fcmToken,\r\n        android: {\r\n          notification: {\r\n            icon: options.icon,\r\n            imageUrl: options.imageUrl,\r\n            sound: options.sound || 'default',\r\n          },\r\n        },\r\n        apns: {\r\n          payload: {\r\n            aps: {\r\n              badge: options.badge,\r\n              sound: options.sound || 'default',\r\n            },\r\n          },\r\n          fcmOptions: {\r\n            imageUrl: options.imageUrl,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Uncomment when firebase-admin is installed:\r\n      // const response = await admin.messaging().send(message);\r\n\r\n      this.logger.info('FCM push notification sent', {\r\n        userId: options.userId,\r\n        title: options.title,\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        messageId: `fcm-${Date.now()}`, // Replace with response\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('FCM send failed', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n      };\r\n    }\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    // Check if credentials are configured\r\n    return !!(this.projectId && this.serviceAccountKey);\r\n  }\r\n\r\n  // Helper method to retrieve user's FCM token from database\r\n  // @ts-ignore - Placeholder for future implementation\r\n  private async getUserFcmToken(userId: string): Promise<string> {\r\n    // TODO: Implement database lookup for user's FCM token\r\n    // This would typically be stored when the user logs in from their device\r\n    throw new Error('FCM token lookup not implemented');\r\n  }\r\n}\r\n\r\n/**\r\n * Installation instructions:\r\n * pnpm add firebase-admin\r\n *\r\n * Environment variables:\r\n * FIREBASE_PROJECT_ID=your_project_id\r\n * FIREBASE_SERVICE_ACCOUNT_KEY='{\"type\":\"service_account\",\"project_id\":\"...\",\"private_key\":\"...\"}'\r\n *\r\n * Note: The service account key should be a JSON string of your Firebase service account credentials\r\n */\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\sendgrid-email.provider.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/ban-ts-comment",
        "severity": 2,
        "message": "Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.",
        "line": 35,
        "column": 7,
        "nodeType": "Line",
        "messageId": "tsIgnoreInsteadOfExpectError",
        "endLine": 35,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "replaceTsIgnoreWithTsExpectError",
            "fix": {
              "range": [1105, 1158],
              "text": "// @ts-expect-error - Used when @sendgrid/mail is installed"
            },
            "desc": "Replace \"@ts-ignore\" with \"@ts-expect-error\"."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'message' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 36,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 36,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { EmailOptions, IEmailProvider, NotificationResult } from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\nimport { LoggerService } from '../../logger.service';\r\n\r\n/**\r\n * SendGrid email provider\r\n * Requires SENDGRID_API_KEY environment variable\r\n */\r\n@injectable()\r\nexport class SendGridEmailProvider implements IEmailProvider {\r\n  private apiKey: string;\r\n  private fromEmail: string;\r\n\r\n  constructor(private logger: LoggerService) {\r\n    this.apiKey = process.env['SENDGRID_API_KEY'] || '';\r\n    this.fromEmail = process.env['SENDGRID_FROM_EMAIL'] || 'noreply@example.com';\r\n\r\n    if (!this.apiKey) {\r\n      this.logger.warn('SendGrid API key not configured. Email sending will fail.');\r\n    }\r\n  }\r\n\r\n  async send(options: EmailOptions): Promise<NotificationResult> {\r\n    try {\r\n      if (!this.apiKey) {\r\n        throw new Error('SendGrid API key not configured');\r\n      }\r\n\r\n      // SendGrid API implementation\r\n      // Note: Install @sendgrid/mail package when ready to use\r\n      // const sgMail = require('@sendgrid/mail');\r\n      // sgMail.setApiKey(this.apiKey);\r\n\r\n      // @ts-ignore - Used when @sendgrid/mail is installed\r\n      const message = {\r\n        to: options.to,\r\n        from: options.from || this.fromEmail,\r\n        subject: options.subject,\r\n        text: options.text,\r\n        html: options.html,\r\n        cc: options.cc,\r\n        bcc: options.bcc,\r\n        attachments: options.attachments?.map((att) => ({\r\n          filename: att.filename,\r\n          content: Buffer.isBuffer(att.content) ? att.content.toString('base64') : att.content,\r\n          type: att.contentType,\r\n          disposition: 'attachment',\r\n        })),\r\n      };\r\n\r\n      // Uncomment when @sendgrid/mail is installed:\r\n      // const [response] = await sgMail.send(message);\r\n\r\n      this.logger.info('SendGrid email sent', {\r\n        to: options.to,\r\n        subject: options.subject,\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        messageId: `sendgrid-${Date.now()}`, // Replace with response.messageId\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('SendGrid send failed', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n      };\r\n    }\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    // Check if API key is configured\r\n    return !!this.apiKey;\r\n  }\r\n}\r\n\r\n/**\r\n * Installation instructions:\r\n * pnpm add @sendgrid/mail\r\n *\r\n * Environment variables:\r\n * SENDGRID_API_KEY=your_sendgrid_api_key\r\n * SENDGRID_FROM_EMAIL=noreply@yourdomain.com\r\n */\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\twilio-sms.provider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\secrets\\secrets-manager.service.ts",
    "messages": [
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Variable Assigned to Object Injection Sink",
        "line": 26,
        "column": 24,
        "nodeType": "MemberExpression",
        "endLine": 26,
        "endColumn": 40
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Variable Assigned to Object Injection Sink",
        "line": 129,
        "column": 21,
        "nodeType": "MemberExpression",
        "endLine": 129,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ISecretsManager, SecretInfo, SecretMetadata } from '@repo/types';\nimport { injectable } from 'tsyringe';\n\n/**\n * Environment-based secrets manager implementation\n * In production, this would integrate with HashiCorp Vault, AWS Secrets Manager, etc.\n */\n@injectable()\nexport class EnvironmentSecretsManager implements ISecretsManager {\n  private secrets: Map<string, { value: string; metadata: SecretMetadata }> = new Map();\n\n  constructor() {\n    this.initializeFromEnv();\n  }\n\n  /**\n   * Get secret value\n   */\n  async getSecret(key: string, _version?: string): Promise<string> {\n    // In production: fetch from Vault/AWS Secrets Manager/Azure Key Vault\n    // The version parameter would be used for versioned secret systems\n    const secret = this.secrets.get(key);\n\n    if (!secret) {\n      // Fall back to environment variable\n      const envValue = process.env[key];\n      if (!envValue) {\n        throw new Error(`Secret not found: ${key}`);\n      }\n      return envValue;\n    }\n\n    return secret.value;\n  }\n\n  /**\n   * Set secret value\n   */\n  async setSecret(key: string, value: string, metadata?: SecretMetadata): Promise<void> {\n    // In production: store in Vault/AWS Secrets Manager/Azure Key Vault\n    const existingSecret = this.secrets.get(key);\n    const secretMetadata: SecretMetadata = {\n      ...metadata,\n      createdAt: existingSecret?.metadata.createdAt || new Date(),\n      updatedAt: new Date(),\n      version: existingSecret ? this.incrementVersion(existingSecret.metadata.version) : '1',\n    };\n\n    this.secrets.set(key, {\n      value,\n      metadata: secretMetadata,\n    });\n  }\n\n  /**\n   * Delete secret\n   */\n  async deleteSecret(key: string): Promise<void> {\n    // In production: delete from Vault/AWS Secrets Manager/Azure Key Vault\n    this.secrets.delete(key);\n  }\n\n  /**\n   * List all secret keys\n   */\n  async listSecrets(prefix?: string): Promise<SecretInfo[]> {\n    // In production: list from Vault/AWS Secrets Manager/Azure Key Vault\n    const secrets: SecretInfo[] = [];\n\n    for (const [key, secret] of this.secrets.entries()) {\n      if (!prefix || key.startsWith(prefix)) {\n        secrets.push({\n          key,\n          metadata: secret.metadata,\n        });\n      }\n    }\n\n    return secrets;\n  }\n\n  /**\n   * Rotate secret\n   */\n  async rotateSecret(key: string, newValue: string): Promise<void> {\n    // In production:\n    // 1. Store new version\n    // 2. Update applications to use new version\n    // 3. Keep old version for grace period\n    // 4. Delete old version after grace period\n\n    const existingSecret = this.secrets.get(key);\n    if (!existingSecret) {\n      throw new Error(`Secret not found: ${key}`);\n    }\n\n    await this.setSecret(key, newValue, {\n      ...existingSecret.metadata,\n      rotationEnabled: true,\n    });\n  }\n\n  /**\n   * Get secret metadata\n   */\n  async getSecretMetadata(key: string): Promise<SecretMetadata> {\n    const secret = this.secrets.get(key);\n    if (!secret) {\n      throw new Error(`Secret not found: ${key}`);\n    }\n\n    return secret.metadata;\n  }\n\n  /**\n   * Initialize secrets from environment variables\n   */\n  private initializeFromEnv(): void {\n    // Load critical secrets from environment\n    const criticalSecrets = [\n      'JWT_ACCESS_SECRET',\n      'JWT_REFRESH_SECRET',\n      'ENCRYPTION_KEY',\n      'DATABASE_URL',\n      'REDIS_URL',\n    ];\n\n    for (const key of criticalSecrets) {\n      const value = process.env[key];\n      if (value) {\n        this.secrets.set(key, {\n          value,\n          metadata: {\n            description: `Loaded from environment: ${key}`,\n            createdAt: new Date(),\n            updatedAt: new Date(),\n            version: '1',\n          },\n        });\n      }\n    }\n  }\n\n  /**\n   * Increment version string\n   */\n  private incrementVersion(version?: string): string {\n    if (!version) return '1';\n    const num = parseInt(version, 10);\n    return (num + 1).toString();\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\providers\\azure-blob-storage.provider.ts",
    "messages": [
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 366,
        "column": 12,
        "nodeType": "MemberExpression",
        "endLine": 366,
        "endColumn": 29
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import crypto from 'crypto';\n\nimport {\n  BlobSASPermissions,\n  BlobServiceClient,\n  ContainerClient,\n  StorageSharedKeyCredential,\n} from '@azure/storage-blob';\nimport {\n  DeleteOptions,\n  DownloadOptions,\n  FileMetadata,\n  IStorageProvider,\n  ListOptions,\n  UploadOptions,\n} from '@repo/types';\nimport { injectable } from 'tsyringe';\n\nimport { LoggerService } from '../../logger.service';\n\n/**\n * Azure Blob Storage provider\n * Stores files in Azure Blob Storage\n */\n@injectable()\nexport class AzureBlobStorageProvider implements IStorageProvider {\n  readonly providerName = 'azure-blob';\n  private readonly blobServiceClient: BlobServiceClient;\n  private readonly defaultContainer: string;\n\n  constructor(private logger: LoggerService) {\n    const accountName = process.env['AZURE_STORAGE_ACCOUNT_NAME'] || '';\n    const accountKey = process.env['AZURE_STORAGE_ACCOUNT_KEY'] || '';\n    this.defaultContainer = process.env['AZURE_STORAGE_CONTAINER'] || 'uploads';\n\n    if (!accountName || !accountKey) {\n      this.logger.warn('Azure Storage credentials not configured');\n      // Create a dummy client to avoid errors\n      this.blobServiceClient = {} as BlobServiceClient;\n    } else {\n      const sharedKeyCredential = new StorageSharedKeyCredential(accountName, accountKey);\n      this.blobServiceClient = new BlobServiceClient(\n        `https://${accountName}.blob.core.windows.net`,\n        sharedKeyCredential\n      );\n    }\n  }\n\n  async upload(\n    file: Buffer | NodeJS.ReadableStream,\n    options: UploadOptions\n  ): Promise<FileMetadata> {\n    try {\n      const filename = options.filename || this.generateFilename(options.contentType);\n      const folder = options.folder || 'default';\n      const blobName = `${folder}/${filename}`;\n      const containerName = options.bucket || this.defaultContainer;\n\n      // Validate file size if it's a Buffer\n      if (options.maxSize && Buffer.isBuffer(file) && file.length > options.maxSize) {\n        throw new Error(`File size ${file.length} exceeds maximum ${options.maxSize} bytes`);\n      }\n\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      await this.ensureContainerExists(containerClient);\n\n      const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n\n      if (Buffer.isBuffer(file)) {\n        await blockBlobClient.upload(file, file.length, {\n          blobHTTPHeaders: {\n            blobContentType: options.contentType || 'application/octet-stream',\n          },\n          metadata: options.metadata,\n        });\n      } else {\n        // @ts-expect-error - Stream type mismatch between web and node streams\n        await blockBlobClient.uploadStream(file, undefined, undefined, {\n          blobHTTPHeaders: {\n            blobContentType: options.contentType || 'application/octet-stream',\n          },\n          metadata: options.metadata,\n        });\n      }\n\n      // Get properties to get the actual size\n      const properties = await blockBlobClient.getProperties();\n\n      const url = blockBlobClient.url;\n\n      const metadata: FileMetadata = {\n        filename,\n        originalName: options.filename || filename,\n        mimeType: properties.contentType || 'application/octet-stream',\n        size: properties.contentLength || 0,\n        path: blobName,\n        url,\n        uploadedAt: properties.lastModified || new Date(),\n        bucket: containerName,\n        key: blobName,\n      };\n\n      this.logger.info('File uploaded to Azure Blob Storage', {\n        container: containerName,\n        blob: blobName,\n        size: metadata.size,\n      });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('Azure Blob upload failed', error as Error);\n      throw error;\n    }\n  }\n\n  async uploadMultiple(\n    files: Array<{ data: Buffer | NodeJS.ReadableStream; options: UploadOptions }>\n  ): Promise<FileMetadata[]> {\n    return Promise.all(files.map((f) => this.upload(f.data, f.options)));\n  }\n\n  async download(filePath: string, options?: DownloadOptions): Promise<Buffer> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      const downloadResponse = await blockBlobClient.download();\n\n      if (!downloadResponse.readableStreamBody) {\n        throw new Error('No stream body in Azure response');\n      }\n\n      const chunks: Buffer[] = [];\n      for await (const chunk of downloadResponse.readableStreamBody) {\n        chunks.push(Buffer.from(chunk));\n      }\n\n      const buffer = Buffer.concat(chunks);\n\n      this.logger.info('File downloaded from Azure Blob Storage', {\n        container: containerName,\n        blob: filePath,\n      });\n\n      return buffer;\n    } catch (_error) {\n      this.logger.error('Azure Blob download failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async getSignedUrl(filePath: string, options?: DownloadOptions): Promise<string> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      const expiresIn = options?.expiresIn || 3600; // 1 hour default\n      const expiryDate = new Date(Date.now() + expiresIn * 1000);\n\n      // Generate SAS token\n      const sasToken = await blockBlobClient.generateSasUrl({\n        permissions: BlobSASPermissions.parse('r'), // read only\n        expiresOn: expiryDate,\n      });\n\n      return sasToken;\n    } catch (error) {\n      this.logger.error('Azure Blob getSignedUrl failed', error as Error);\n      throw error;\n    }\n  }\n\n  async delete(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      await blockBlobClient.delete();\n\n      this.logger.info('File deleted from Azure Blob Storage', {\n        container: containerName,\n        blob: filePath,\n      });\n\n      return true;\n    } catch (_error) {\n      this.logger.error('Azure Blob delete failed', _error as Error);\n      return false;\n    }\n  }\n\n  async deleteMultiple(paths: string[], options?: DeleteOptions): Promise<boolean[]> {\n    return Promise.all(paths.map((p) => this.delete(p, options)));\n  }\n\n  async exists(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      return await blockBlobClient.exists();\n    } catch {\n      return false;\n    }\n  }\n\n  async list(options?: ListOptions): Promise<FileMetadata[]> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const folder = options?.folder || '';\n      const prefix = options?.prefix || folder;\n\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n\n      const files: FileMetadata[] = [];\n      let count = 0;\n      const maxResults = options?.maxResults || 1000;\n\n      for await (const blob of containerClient.listBlobsFlat({ prefix })) {\n        if (count >= maxResults) break;\n\n        files.push({\n          filename: blob.name.split('/').pop() || '',\n          originalName: blob.name.split('/').pop() || '',\n          mimeType: blob.properties.contentType || 'application/octet-stream',\n          size: blob.properties.contentLength || 0,\n          path: blob.name,\n          url: `${containerClient.url}/${blob.name}`,\n          uploadedAt: blob.properties.lastModified || new Date(),\n          bucket: containerName,\n          key: blob.name,\n        });\n\n        count++;\n      }\n\n      return files;\n    } catch (error) {\n      this.logger.error('Azure Blob list failed', error as Error);\n      return [];\n    }\n  }\n\n  async getMetadata(filePath: string, options?: DeleteOptions): Promise<FileMetadata> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      const properties = await blockBlobClient.getProperties();\n\n      return {\n        filename: filePath.split('/').pop() || '',\n        originalName: filePath.split('/').pop() || '',\n        mimeType: properties.contentType || 'application/octet-stream',\n        size: properties.contentLength || 0,\n        path: filePath,\n        url: blockBlobClient.url,\n        uploadedAt: properties.lastModified || new Date(),\n        bucket: containerName,\n        key: filePath,\n      };\n    } catch (error) {\n      this.logger.error('Azure Blob getMetadata failed', error as Error);\n      throw error;\n    }\n  }\n\n  async copy(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n\n      const sourceBlob = containerClient.getBlockBlobClient(sourcePath);\n      const destBlob = containerClient.getBlockBlobClient(destinationPath);\n\n      await destBlob.beginCopyFromURL(sourceBlob.url);\n\n      this.logger.info('File copied in Azure Blob Storage', {\n        container: containerName,\n        from: sourcePath,\n        to: destinationPath,\n      });\n\n      return this.getMetadata(destinationPath, options);\n    } catch (error) {\n      this.logger.error('Azure Blob copy failed', error as Error);\n      throw error;\n    }\n  }\n\n  async move(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const metadata = await this.copy(sourcePath, destinationPath, options);\n      await this.delete(sourcePath, options);\n\n      this.logger.info('File moved in Azure Blob Storage', {\n        from: sourcePath,\n        to: destinationPath,\n      });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('Azure Blob move failed', error as Error);\n      throw error;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      const containerClient = this.blobServiceClient.getContainerClient(this.defaultContainer);\n      await containerClient.exists();\n      return true;\n    } catch (error) {\n      this.logger.error('Azure Blob health check failed', error as Error);\n      return false;\n    }\n  }\n\n  // Helper methods\n\n  private async ensureContainerExists(containerClient: ContainerClient): Promise<void> {\n    try {\n      const exists = await containerClient.exists();\n      if (!exists) {\n        await containerClient.create();\n      }\n    } catch {\n      // Container might already exist\n    }\n  }\n\n  private generateFilename(mimeType?: string): string {\n    const timestamp = Date.now();\n    const random = crypto.randomBytes(8).toString('hex');\n    const ext = mimeType ? this.getExtensionFromMimeType(mimeType) : '';\n\n    return `${timestamp}-${random}${ext}`;\n  }\n\n  private getExtensionFromMimeType(mimeType: string): string {\n    const mimeMap: Record<string, string> = {\n      'image/jpeg': '.jpg',\n      'image/png': '.png',\n      'image/gif': '.gif',\n      'image/webp': '.webp',\n      'application/pdf': '.pdf',\n      'text/plain': '.txt',\n      'application/json': '.json',\n      'video/mp4': '.mp4',\n      'audio/mpeg': '.mp3',\n    };\n\n    return mimeMap[mimeType] || '';\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\providers\\gcp-storage.provider.ts",
    "messages": [
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 354,
        "column": 12,
        "nodeType": "MemberExpression",
        "endLine": 354,
        "endColumn": 29
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import crypto from 'crypto';\n\nimport { Storage } from '@google-cloud/storage';\nimport {\n  DeleteOptions,\n  DownloadOptions,\n  FileMetadata,\n  IStorageProvider,\n  ListOptions,\n  UploadOptions,\n} from '@repo/types';\nimport { injectable } from 'tsyringe';\n\nimport { LoggerService } from '../../logger.service';\n\n/**\n * Google Cloud Storage provider\n * Stores files in Google Cloud Storage\n */\n@injectable()\nexport class GcpStorageProvider implements IStorageProvider {\n  readonly providerName = 'gcp-storage';\n  private readonly storage: Storage;\n  private readonly defaultBucket: string;\n\n  constructor(private logger: LoggerService) {\n    const projectId = process.env['GCP_PROJECT_ID'];\n    const keyFilename = process.env['GCP_KEY_FILE'];\n    this.defaultBucket = process.env['GCP_STORAGE_BUCKET'] || '';\n\n    if (!projectId || !keyFilename) {\n      this.logger.warn('GCP credentials not configured');\n      this.storage = {} as Storage;\n    } else {\n      this.storage = new Storage({\n        projectId,\n        keyFilename,\n      });\n    }\n\n    if (!this.defaultBucket) {\n      this.logger.warn('GCP_STORAGE_BUCKET not configured');\n    }\n  }\n\n  async upload(\n    file: Buffer | NodeJS.ReadableStream,\n    options: UploadOptions\n  ): Promise<FileMetadata> {\n    try {\n      const filename = options.filename || this.generateFilename(options.contentType);\n      const folder = options.folder || 'default';\n      const blobName = `${folder}/${filename}`;\n      const bucketName = options.bucket || this.defaultBucket;\n\n      // Validate file size if it's a Buffer\n      if (options.maxSize && Buffer.isBuffer(file) && file.length > options.maxSize) {\n        throw new Error(`File size ${file.length} exceeds maximum ${options.maxSize} bytes`);\n      }\n\n      const bucket = this.storage.bucket(bucketName);\n      const blob = bucket.file(blobName);\n\n      const uploadOptions = {\n        metadata: {\n          contentType: options.contentType || 'application/octet-stream',\n          metadata: options.metadata,\n        },\n        public: options.makePublic || false,\n      };\n\n      if (Buffer.isBuffer(file)) {\n        await blob.save(file, uploadOptions);\n      } else {\n        // Handle stream\n        await new Promise<void>((resolve, reject) => {\n          file\n            .pipe(\n              blob.createWriteStream({\n                metadata: uploadOptions.metadata,\n                public: uploadOptions.public,\n              })\n            )\n            .on('error', reject)\n            .on('finish', resolve);\n        });\n      }\n\n      // Get metadata\n      const [metadata] = await blob.getMetadata();\n\n      const url = options.makePublic\n        ? `https://storage.googleapis.com/${bucketName}/${blobName}`\n        : await this.getSignedUrl(blobName, { bucket: bucketName });\n\n      const fileMetadata: FileMetadata = {\n        filename,\n        originalName: options.filename || filename,\n        mimeType: metadata.contentType || 'application/octet-stream',\n        size: parseInt(String(metadata.size || '0'), 10),\n        path: blobName,\n        url,\n        uploadedAt: new Date(metadata.timeCreated || Date.now()),\n        bucket: bucketName,\n        key: blobName,\n      };\n\n      this.logger.info('File uploaded to GCP Storage', {\n        bucket: bucketName,\n        blob: blobName,\n        size: fileMetadata.size,\n      });\n\n      return fileMetadata;\n    } catch (_error) {\n      this.logger.error('GCP Storage upload failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async uploadMultiple(\n    files: Array<{ data: Buffer | NodeJS.ReadableStream; options: UploadOptions }>\n  ): Promise<FileMetadata[]> {\n    return Promise.all(files.map((f) => this.upload(f.data, f.options)));\n  }\n\n  async download(filePath: string, options?: DownloadOptions): Promise<Buffer> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      const [buffer] = await file.download();\n\n      this.logger.info('File downloaded from GCP Storage', {\n        bucket: bucketName,\n        file: filePath,\n      });\n\n      return buffer;\n    } catch (_error) {\n      this.logger.error('GCP Storage download failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async getSignedUrl(filePath: string, options?: DownloadOptions): Promise<string> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      const expiresIn = options?.expiresIn || 3600; // 1 hour default\n      const expiryDate = Date.now() + expiresIn * 1000;\n\n      const [url] = await file.getSignedUrl({\n        action: 'read',\n        expires: expiryDate,\n      });\n\n      return url;\n    } catch (_error) {\n      this.logger.error('GCP Storage getSignedUrl failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async delete(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      await file.delete();\n\n      this.logger.info('File deleted from GCP Storage', {\n        bucket: bucketName,\n        file: filePath,\n      });\n\n      return true;\n    } catch (_error) {\n      this.logger.error('GCP Storage delete failed', _error as Error);\n      return false;\n    }\n  }\n\n  async deleteMultiple(paths: string[], options?: DeleteOptions): Promise<boolean[]> {\n    return Promise.all(paths.map((p) => this.delete(p, options)));\n  }\n\n  async exists(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      const [exists] = await file.exists();\n      return exists;\n    } catch {\n      return false;\n    }\n  }\n\n  async list(options?: ListOptions): Promise<FileMetadata[]> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const folder = options?.folder || '';\n      const prefix = options?.prefix || folder;\n\n      const bucket = this.storage.bucket(bucketName);\n\n      const [files] = await bucket.getFiles({\n        prefix,\n        maxResults: options?.maxResults || 1000,\n      });\n\n      const fileMetadata: FileMetadata[] = await Promise.all(\n        files.map(async (file) => {\n          const [metadata] = await file.getMetadata();\n\n          return {\n            filename: file.name.split('/').pop() || '',\n            originalName: file.name.split('/').pop() || '',\n            mimeType: metadata.contentType || 'application/octet-stream',\n            size: parseInt(String(metadata.size || '0'), 10),\n            path: file.name,\n            url: `https://storage.googleapis.com/${bucketName}/${file.name}`,\n            uploadedAt: new Date(metadata.timeCreated || Date.now()),\n            bucket: bucketName,\n            key: file.name,\n          };\n        })\n      );\n\n      return fileMetadata;\n    } catch (_error) {\n      this.logger.error('GCP Storage list failed', _error as Error);\n      return [];\n    }\n  }\n\n  async getMetadata(filePath: string, options?: DeleteOptions): Promise<FileMetadata> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      const [metadata] = await file.getMetadata();\n\n      return {\n        filename: filePath.split('/').pop() || '',\n        originalName: filePath.split('/').pop() || '',\n        mimeType: metadata.contentType || 'application/octet-stream',\n        size: parseInt(String(metadata.size || '0'), 10),\n        path: filePath,\n        url: `https://storage.googleapis.com/${bucketName}/${filePath}`,\n        uploadedAt: new Date(metadata.timeCreated || Date.now()),\n        bucket: bucketName,\n        key: filePath,\n      };\n    } catch (_error) {\n      this.logger.error('GCP Storage getMetadata failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async copy(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const sourceFile = bucket.file(sourcePath);\n      const destFile = bucket.file(destinationPath);\n\n      await sourceFile.copy(destFile);\n\n      this.logger.info('File copied in GCP Storage', {\n        bucket: bucketName,\n        from: sourcePath,\n        to: destinationPath,\n      });\n\n      return this.getMetadata(destinationPath, options);\n    } catch (_error) {\n      this.logger.error('GCP Storage copy failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async move(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const sourceFile = bucket.file(sourcePath);\n      const destFile = bucket.file(destinationPath);\n\n      await sourceFile.move(destFile);\n\n      this.logger.info('File moved in GCP Storage', {\n        bucket: bucketName,\n        from: sourcePath,\n        to: destinationPath,\n      });\n\n      return this.getMetadata(destinationPath, options);\n    } catch (_error) {\n      this.logger.error('GCP Storage move failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      const bucket = this.storage.bucket(this.defaultBucket);\n      await bucket.exists();\n      return true;\n    } catch (_error) {\n      this.logger.error('GCP Storage health check failed', _error as Error);\n      return false;\n    }\n  }\n\n  // Helper methods\n\n  private generateFilename(mimeType?: string): string {\n    const timestamp = Date.now();\n    const random = crypto.randomBytes(8).toString('hex');\n    const ext = mimeType ? this.getExtensionFromMimeType(mimeType) : '';\n\n    return `${timestamp}-${random}${ext}`;\n  }\n\n  private getExtensionFromMimeType(mimeType: string): string {\n    const mimeMap: Record<string, string> = {\n      'image/jpeg': '.jpg',\n      'image/png': '.png',\n      'image/gif': '.gif',\n      'image/webp': '.webp',\n      'application/pdf': '.pdf',\n      'text/plain': '.txt',\n      'application/json': '.json',\n      'video/mp4': '.mp4',\n      'audio/mpeg': '.mp3',\n    };\n\n    return mimeMap[mimeType] || '';\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\providers\\local-storage.provider.ts",
    "messages": [
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found writeFile from package \"fs/promises\" with non literal argument at index 0",
        "line": 58,
        "column": 15,
        "nodeType": "CallExpression",
        "endLine": 58,
        "endColumn": 43
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found createWriteStream from package \"fs\" with non literal argument at index 0",
        "line": 61,
        "column": 29,
        "nodeType": "CallExpression",
        "endLine": 61,
        "endColumn": 56
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found stat from package \"fs/promises\" with non literal argument at index 0",
        "line": 70,
        "column": 27,
        "nodeType": "CallExpression",
        "endLine": 70,
        "endColumn": 44
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found readFile from package \"fs/promises\" with non literal argument at index 0",
        "line": 100,
        "column": 28,
        "nodeType": "CallExpression",
        "endLine": 100,
        "endColumn": 49
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found unlink from package \"fs/promises\" with non literal argument at index 0",
        "line": 120,
        "column": 13,
        "nodeType": "CallExpression",
        "endLine": 120,
        "endColumn": 32
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found stat from package \"fs/promises\" with non literal argument at index 0",
        "line": 172,
        "column": 27,
        "nodeType": "CallExpression",
        "endLine": 172,
        "endColumn": 44
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found rename from package \"fs/promises\" with non literal argument at index 0,1",
        "line": 224,
        "column": 13,
        "nodeType": "CallExpression",
        "endLine": 224,
        "endColumn": 52
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found writeFile from package \"fs/promises\" with non literal argument at index 0",
        "line": 242,
        "column": 13,
        "nodeType": "CallExpression",
        "endLine": 242,
        "endColumn": 41
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found unlink from package \"fs/promises\" with non literal argument at index 0",
        "line": 243,
        "column": 13,
        "nodeType": "CallExpression",
        "endLine": 243,
        "endColumn": 32
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found mkdir from package \"fs/promises\" with non literal argument at index 0",
        "line": 256,
        "column": 13,
        "nodeType": "CallExpression",
        "endLine": 256,
        "endColumn": 51
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 286,
        "column": 12,
        "nodeType": "MemberExpression",
        "endLine": 286,
        "endColumn": 29
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found readdir from package \"fs/promises\" with non literal argument at index 0",
        "line": 293,
        "column": 29,
        "nodeType": "CallExpression",
        "endLine": 293,
        "endColumn": 73
      },
      {
        "ruleId": "security/detect-non-literal-fs-filename",
        "severity": 1,
        "message": "Found stat from package \"fs/promises\" with non literal argument at index 0",
        "line": 303,
        "column": 31,
        "nodeType": "CallExpression",
        "endLine": 303,
        "endColumn": 48
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import crypto from 'crypto';\nimport { createWriteStream } from 'fs';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nimport {\n  DeleteOptions,\n  DownloadOptions,\n  FileMetadata,\n  IStorageProvider,\n  ListOptions,\n  UploadOptions,\n} from '@repo/types';\nimport { injectable } from 'tsyringe';\n\nimport { LoggerService } from '../../logger.service';\n\n/**\n * Local filesystem storage provider\n * Stores files in the local filesystem (development and testing)\n */\n@injectable()\nexport class LocalStorageProvider implements IStorageProvider {\n  readonly providerName = 'local';\n  private readonly basePath: string;\n  private readonly baseUrl: string;\n\n  constructor(private logger: LoggerService) {\n    this.basePath = process.env['STORAGE_PATH'] || path.join(process.cwd(), 'uploads');\n    this.baseUrl = process.env['STORAGE_BASE_URL'] || 'http://localhost:3001/uploads';\n\n    // Ensure base directory exists\n    this.ensureDirectory(this.basePath).catch((error) => {\n      this.logger.error('Failed to create storage directory', error);\n    });\n  }\n\n  async upload(\n    file: Buffer | NodeJS.ReadableStream,\n    options: UploadOptions\n  ): Promise<FileMetadata> {\n    try {\n      const filename = options.filename || this.generateFilename(options.contentType);\n      const folder = options.folder || 'default';\n      const filePath = path.join(folder, filename);\n      const fullPath = path.join(this.basePath, filePath);\n\n      // Ensure folder exists\n      await this.ensureDirectory(path.dirname(fullPath));\n\n      // Validate file size\n      if (options.maxSize && Buffer.isBuffer(file) && file.length > options.maxSize) {\n        throw new Error(`File size ${file.length} exceeds maximum ${options.maxSize} bytes`);\n      }\n\n      // Write file\n      if (Buffer.isBuffer(file)) {\n        await fs.writeFile(fullPath, file);\n      } else {\n        // Handle stream\n        const writeStream = createWriteStream(fullPath);\n        await new Promise<void>((resolve, reject) => {\n          file.pipe(writeStream);\n          file.on('error', reject);\n          writeStream.on('finish', () => resolve());\n          writeStream.on('error', reject);\n        });\n      }\n\n      const stats = await fs.stat(fullPath);\n\n      const metadata: FileMetadata = {\n        filename,\n        originalName: options.filename || filename,\n        mimeType: options.contentType || 'application/octet-stream',\n        size: stats.size,\n        path: filePath,\n        url: `${this.baseUrl}/${filePath}`,\n        uploadedAt: new Date(),\n      };\n\n      this.logger.info('File uploaded to local storage', { path: filePath, size: stats.size });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('Local storage upload failed', error as Error);\n      throw error;\n    }\n  }\n\n  async uploadMultiple(\n    files: Array<{ data: Buffer | NodeJS.ReadableStream; options: UploadOptions }>\n  ): Promise<FileMetadata[]> {\n    return Promise.all(files.map((f) => this.upload(f.data, f.options)));\n  }\n\n  async download(filePath: string, _options?: DownloadOptions): Promise<Buffer> {\n    try {\n      const fullPath = path.join(this.basePath, filePath);\n      const buffer = await fs.readFile(fullPath);\n\n      this.logger.info('File downloaded from local storage', { path: filePath });\n\n      return buffer;\n    } catch (error) {\n      this.logger.error('Local storage download failed', error as Error);\n      throw error;\n    }\n  }\n\n  async getSignedUrl(filePath: string, _options?: DownloadOptions): Promise<string> {\n    // For local storage, return the direct URL\n    // In production, this could return a signed URL with expiration\n    return `${this.baseUrl}/${filePath}`;\n  }\n\n  async delete(filePath: string, _options?: DeleteOptions): Promise<boolean> {\n    try {\n      const fullPath = path.join(this.basePath, filePath);\n      await fs.unlink(fullPath);\n\n      this.logger.info('File deleted from local storage', { path: filePath });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Local storage delete failed', error as Error);\n      return false;\n    }\n  }\n\n  async deleteMultiple(paths: string[], options?: DeleteOptions): Promise<boolean[]> {\n    return Promise.all(paths.map((p) => this.delete(p, options)));\n  }\n\n  async exists(filePath: string, _options?: DeleteOptions): Promise<boolean> {\n    try {\n      const fullPath = path.join(this.basePath, filePath);\n      await fs.access(fullPath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async list(options?: ListOptions): Promise<FileMetadata[]> {\n    try {\n      const folder = options?.folder || '';\n      const fullPath = path.join(this.basePath, folder);\n\n      const files = await this.listFilesRecursive(fullPath, folder);\n\n      // Apply prefix filter if provided\n      const filteredFiles = options?.prefix\n        ? files.filter((f) => f.path.startsWith(options.prefix!))\n        : files;\n\n      // Apply max results limit\n      const limitedFiles = options?.maxResults\n        ? filteredFiles.slice(0, options.maxResults)\n        : filteredFiles;\n\n      return limitedFiles;\n    } catch (error) {\n      this.logger.error('Local storage list failed', error as Error);\n      return [];\n    }\n  }\n\n  async getMetadata(filePath: string, _options?: DeleteOptions): Promise<FileMetadata> {\n    try {\n      const fullPath = path.join(this.basePath, filePath);\n      const stats = await fs.stat(fullPath);\n\n      return {\n        filename: path.basename(filePath),\n        originalName: path.basename(filePath),\n        mimeType: 'application/octet-stream', // Would need mime-type detection\n        size: stats.size,\n        path: filePath,\n        url: `${this.baseUrl}/${filePath}`,\n        uploadedAt: stats.birthtime,\n      };\n    } catch (error) {\n      this.logger.error('Local storage getMetadata failed', error as Error);\n      throw error;\n    }\n  }\n\n  async copy(\n    sourcePath: string,\n    destinationPath: string,\n    _options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const sourceFullPath = path.join(this.basePath, sourcePath);\n      const destFullPath = path.join(this.basePath, destinationPath);\n\n      // Ensure destination directory exists\n      await this.ensureDirectory(path.dirname(destFullPath));\n\n      await fs.copyFile(sourceFullPath, destFullPath);\n\n      this.logger.info('File copied in local storage', { from: sourcePath, to: destinationPath });\n\n      return this.getMetadata(destinationPath);\n    } catch (error) {\n      this.logger.error('Local storage copy failed', error as Error);\n      throw error;\n    }\n  }\n\n  async move(\n    sourcePath: string,\n    destinationPath: string,\n    _options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const sourceFullPath = path.join(this.basePath, sourcePath);\n      const destFullPath = path.join(this.basePath, destinationPath);\n\n      // Ensure destination directory exists\n      await this.ensureDirectory(path.dirname(destFullPath));\n\n      await fs.rename(sourceFullPath, destFullPath);\n\n      this.logger.info('File moved in local storage', { from: sourcePath, to: destinationPath });\n\n      return this.getMetadata(destinationPath);\n    } catch (error) {\n      this.logger.error('Local storage move failed', error as Error);\n      throw error;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      // Check if base directory is accessible\n      await fs.access(this.basePath);\n\n      // Try to write a test file\n      const testPath = path.join(this.basePath, '.healthcheck');\n      await fs.writeFile(testPath, 'ok');\n      await fs.unlink(testPath);\n\n      return true;\n    } catch (error) {\n      this.logger.error('Local storage health check failed', error as Error);\n      return false;\n    }\n  }\n\n  // Helper methods\n\n  private async ensureDirectory(dirPath: string): Promise<void> {\n    try {\n      await fs.mkdir(dirPath, { recursive: true });\n    } catch (error) {\n      // Directory might already exist\n      if ((error as NodeJS.ErrnoException).code !== 'EEXIST') {\n        throw error;\n      }\n    }\n  }\n\n  private generateFilename(mimeType?: string): string {\n    const timestamp = Date.now();\n    const random = crypto.randomBytes(8).toString('hex');\n    const ext = mimeType ? this.getExtensionFromMimeType(mimeType) : '';\n\n    return `${timestamp}-${random}${ext}`;\n  }\n\n  private getExtensionFromMimeType(mimeType: string): string {\n    const mimeMap: Record<string, string> = {\n      'image/jpeg': '.jpg',\n      'image/png': '.png',\n      'image/gif': '.gif',\n      'image/webp': '.webp',\n      'application/pdf': '.pdf',\n      'text/plain': '.txt',\n      'application/json': '.json',\n      'video/mp4': '.mp4',\n      'audio/mpeg': '.mp3',\n    };\n\n    return mimeMap[mimeType] || '';\n  }\n\n  private async listFilesRecursive(dirPath: string, relativePath: string): Promise<FileMetadata[]> {\n    const results: FileMetadata[] = [];\n\n    try {\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dirPath, entry.name);\n        const relPath = path.join(relativePath, entry.name);\n\n        if (entry.isDirectory()) {\n          const subFiles = await this.listFilesRecursive(fullPath, relPath);\n          results.push(...subFiles);\n        } else if (entry.isFile()) {\n          const stats = await fs.stat(fullPath);\n          results.push({\n            filename: entry.name,\n            originalName: entry.name,\n            mimeType: 'application/octet-stream',\n            size: stats.size,\n            path: relPath.replace(/\\\\/g, '/'),\n            url: `${this.baseUrl}/${relPath.replace(/\\\\/g, '/')}`,\n            uploadedAt: stats.birthtime,\n          });\n        }\n      }\n    } catch {\n      // Directory might not exist\n    }\n\n    return results;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\providers\\s3-storage.provider.ts",
    "messages": [
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 378,
        "column": 12,
        "nodeType": "MemberExpression",
        "endLine": 378,
        "endColumn": 29
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import crypto from 'crypto';\n\nimport {\n  CopyObjectCommand,\n  DeleteObjectCommand,\n  DeleteObjectsCommand,\n  GetObjectCommand,\n  HeadObjectCommand,\n  ListObjectsV2Command,\n  PutObjectCommand,\n  S3Client,\n} from '@aws-sdk/client-s3';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner';\nimport {\n  DeleteOptions,\n  DownloadOptions,\n  FileMetadata,\n  IStorageProvider,\n  ListOptions,\n  UploadOptions,\n} from '@repo/types';\nimport { injectable } from 'tsyringe';\n\nimport { LoggerService } from '../../logger.service';\n\n/**\n * AWS S3 storage provider\n * Stores files in Amazon S3\n */\n@injectable()\nexport class S3StorageProvider implements IStorageProvider {\n  readonly providerName = 'aws-s3';\n  private readonly client: S3Client;\n  private readonly defaultBucket: string;\n\n  constructor(private logger: LoggerService) {\n    const region = process.env['AWS_REGION'] || 'us-east-1';\n    this.defaultBucket = process.env['AWS_S3_BUCKET'] || '';\n\n    this.client = new S3Client({\n      region,\n      credentials: {\n        accessKeyId: process.env['AWS_ACCESS_KEY_ID'] || '',\n        secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'] || '',\n      },\n    });\n\n    if (!this.defaultBucket) {\n      this.logger.warn('AWS_S3_BUCKET not configured, S3 storage may not work correctly');\n    }\n  }\n\n  async upload(\n    file: Buffer | NodeJS.ReadableStream,\n    options: UploadOptions\n  ): Promise<FileMetadata> {\n    try {\n      const filename = options.filename || this.generateFilename(options.contentType);\n      const folder = options.folder || 'default';\n      const key = `${folder}/${filename}`;\n      const bucket = options.bucket || this.defaultBucket;\n\n      // Validate file size if it's a Buffer\n      if (options.maxSize && Buffer.isBuffer(file) && file.length > options.maxSize) {\n        throw new Error(`File size ${file.length} exceeds maximum ${options.maxSize} bytes`);\n      }\n\n      const command = new PutObjectCommand({\n        Bucket: bucket,\n        Key: key,\n        // @ts-expect-error - ReadableStream type mismatch between web and node\n        Body: file,\n        ContentType: options.contentType || 'application/octet-stream',\n        Metadata: options.metadata,\n        ACL: options.makePublic ? 'public-read' : 'private',\n      });\n\n      await this.client.send(command);\n\n      // Get the uploaded file's metadata\n      const headCommand = new HeadObjectCommand({\n        Bucket: bucket,\n        Key: key,\n      });\n\n      const headResult = await this.client.send(headCommand);\n\n      const url = options.makePublic\n        ? `https://${bucket}.s3.amazonaws.com/${key}`\n        : await this.getSignedUrl(key, { bucket });\n\n      const metadata: FileMetadata = {\n        filename,\n        originalName: options.filename || filename,\n        mimeType: headResult.ContentType || 'application/octet-stream',\n        size: headResult.ContentLength || 0,\n        path: key,\n        url,\n        uploadedAt: headResult.LastModified || new Date(),\n        bucket,\n        key,\n      };\n\n      this.logger.info('File uploaded to S3', { bucket, key, size: metadata.size });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('S3 upload failed', error as Error);\n      throw error;\n    }\n  }\n\n  async uploadMultiple(\n    files: Array<{ data: Buffer | NodeJS.ReadableStream; options: UploadOptions }>\n  ): Promise<FileMetadata[]> {\n    return Promise.all(files.map((f) => this.upload(f.data, f.options)));\n  }\n\n  async download(filePath: string, options?: DownloadOptions): Promise<Buffer> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new GetObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      const response = await this.client.send(command);\n\n      if (!response.Body) {\n        throw new Error('No body in S3 response');\n      }\n\n      const chunks: Uint8Array[] = [];\n      for await (const chunk of response.Body as AsyncIterable<Uint8Array>) {\n        chunks.push(chunk);\n      }\n\n      const buffer = Buffer.concat(chunks);\n\n      this.logger.info('File downloaded from S3', { bucket, key: filePath });\n\n      return buffer;\n    } catch (error) {\n      this.logger.error('S3 download failed', error as Error);\n      throw error;\n    }\n  }\n\n  async getSignedUrl(filePath: string, options?: DownloadOptions): Promise<string> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n      const expiresIn = options?.expiresIn || 3600; // 1 hour default\n\n      const command = new GetObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      const url = await getSignedUrl(this.client, command, { expiresIn });\n\n      return url;\n    } catch (error) {\n      this.logger.error('S3 getSignedUrl failed', error as Error);\n      throw error;\n    }\n  }\n\n  async delete(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new DeleteObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      await this.client.send(command);\n\n      this.logger.info('File deleted from S3', { bucket, key: filePath });\n\n      return true;\n    } catch (error) {\n      this.logger.error('S3 delete failed', error as Error);\n      return false;\n    }\n  }\n\n  async deleteMultiple(paths: string[], options?: DeleteOptions): Promise<boolean[]> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      if (paths.length === 0) {\n        return [];\n      }\n\n      const command = new DeleteObjectsCommand({\n        Bucket: bucket,\n        Delete: {\n          Objects: paths.map((key) => ({ Key: key })),\n        },\n      });\n\n      const response = await this.client.send(command);\n\n      const deletedKeys = new Set(response.Deleted?.map((d) => d.Key) || []);\n      const results = paths.map((path) => deletedKeys.has(path));\n\n      this.logger.info('Multiple files deleted from S3', { bucket, count: deletedKeys.size });\n\n      return results;\n    } catch (error) {\n      this.logger.error('S3 deleteMultiple failed', error as Error);\n      return paths.map(() => false);\n    }\n  }\n\n  async exists(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new HeadObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      await this.client.send(command);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async list(options?: ListOptions): Promise<FileMetadata[]> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n      const folder = options?.folder || '';\n      const prefix = options?.prefix || folder;\n\n      const command = new ListObjectsV2Command({\n        Bucket: bucket,\n        Prefix: prefix,\n        MaxKeys: options?.maxResults || 1000,\n      });\n\n      const response = await this.client.send(command);\n\n      const files: FileMetadata[] = (response.Contents || []).map((item) => ({\n        filename: item.Key?.split('/').pop() || '',\n        originalName: item.Key?.split('/').pop() || '',\n        mimeType: 'application/octet-stream',\n        size: item.Size || 0,\n        path: item.Key || '',\n        url: `https://${bucket}.s3.amazonaws.com/${item.Key}`,\n        uploadedAt: item.LastModified || new Date(),\n        bucket,\n        key: item.Key || '',\n      }));\n\n      return files;\n    } catch (error) {\n      this.logger.error('S3 list failed', error as Error);\n      return [];\n    }\n  }\n\n  async getMetadata(filePath: string, options?: DeleteOptions): Promise<FileMetadata> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new HeadObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      const response = await this.client.send(command);\n\n      return {\n        filename: filePath.split('/').pop() || '',\n        originalName: filePath.split('/').pop() || '',\n        mimeType: response.ContentType || 'application/octet-stream',\n        size: response.ContentLength || 0,\n        path: filePath,\n        url: `https://${bucket}.s3.amazonaws.com/${filePath}`,\n        uploadedAt: response.LastModified || new Date(),\n        bucket,\n        key: filePath,\n      };\n    } catch (error) {\n      this.logger.error('S3 getMetadata failed', error as Error);\n      throw error;\n    }\n  }\n\n  async copy(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new CopyObjectCommand({\n        Bucket: bucket,\n        CopySource: `${bucket}/${sourcePath}`,\n        Key: destinationPath,\n      });\n\n      await this.client.send(command);\n\n      this.logger.info('File copied in S3', { bucket, from: sourcePath, to: destinationPath });\n\n      return this.getMetadata(destinationPath, options);\n    } catch (error) {\n      this.logger.error('S3 copy failed', error as Error);\n      throw error;\n    }\n  }\n\n  async move(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      // Copy then delete\n      const metadata = await this.copy(sourcePath, destinationPath, options);\n      await this.delete(sourcePath, options);\n\n      this.logger.info('File moved in S3', { from: sourcePath, to: destinationPath });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('S3 move failed', error as Error);\n      throw error;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      // Try to list objects with max 1 result\n      const command = new ListObjectsV2Command({\n        Bucket: this.defaultBucket,\n        MaxKeys: 1,\n      });\n\n      await this.client.send(command);\n      return true;\n    } catch (error) {\n      this.logger.error('S3 health check failed', error as Error);\n      return false;\n    }\n  }\n\n  // Helper methods\n\n  private generateFilename(mimeType?: string): string {\n    const timestamp = Date.now();\n    const random = crypto.randomBytes(8).toString('hex');\n    const ext = mimeType ? this.getExtensionFromMimeType(mimeType) : '';\n\n    return `${timestamp}-${random}${ext}`;\n  }\n\n  private getExtensionFromMimeType(mimeType: string): string {\n    const mimeMap: Record<string, string> = {\n      'image/jpeg': '.jpg',\n      'image/png': '.png',\n      'image/gif': '.gif',\n      'image/webp': '.webp',\n      'application/pdf': '.pdf',\n      'text/plain': '.txt',\n      'application/json': '.json',\n      'video/mp4': '.mp4',\n      'audio/mpeg': '.mp3',\n    };\n\n    return mimeMap[mimeType] || '';\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\storage-provider.factory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\storage.service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\user\\user.service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\webhook\\webhook.service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\abac-scenarios.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\abac.integration.test.ts",
    "messages": [
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 16,
        "column": 70,
        "nodeType": "MemberExpression",
        "endLine": 16,
        "endColumn": 82
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 20,
        "column": 61,
        "nodeType": "MemberExpression",
        "endLine": 20,
        "endColumn": 73
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, expect, it } from 'vitest';\n\ndescribe('ABAC (Attribute-Based Access Control) smoke test', () => {\n  it('grants or denies access based on matching attributes', () => {\n    const userAttrs = {\n      department: 'engineering',\n      level: 'senior',\n      clearance: 'confidential',\n    } as Record<string, string>;\n\n    const requirements = {\n      department: 'engineering',\n      clearance: 'confidential',\n    } as Record<string, string>;\n\n    const hasAccess = Object.entries(requirements).every(([k, v]) => userAttrs[k] === v);\n    expect(hasAccess).toBe(true);\n\n    const badReq = { department: 'sales' };\n    const denied = Object.entries(badReq).every(([k, v]) => userAttrs[k] === v);\n    expect(denied).toBe(false);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\audit_log.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\authorization.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\cache_rate_limit.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\cors.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\database.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\di.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\encryption.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\input_validation.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\logout.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\password_strength.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\rate_limit.integration.test.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 12,
        "column": 19,
        "nodeType": "MemberExpression",
        "endLine": 12,
        "endColumn": 28,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 19,
        "column": 5,
        "nodeType": "MemberExpression",
        "endLine": 19,
        "endColumn": 14,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\redis.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\secrets.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\security.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\session.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\user.routes.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\services\\encryption.service.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\services\\jwt.service.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\services\\logger.service.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\services\\policy-engine.service.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\setup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\types\\express.d.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'Request' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Express type extensions for custom properties\r\n */\r\n\r\nimport { Request } from 'express';\r\n\r\ndeclare global {\r\n  namespace Express {\r\n    interface Request {\r\n      /**\r\n       * API version from header/query parameter\r\n       */\r\n      apiVersion?: string;\r\n\r\n      /**\r\n       * Authenticated user information\r\n       */\r\n      user?: {\r\n        id: string;\r\n        email?: string;\r\n        roles?: string[];\r\n        [key: string]: unknown;\r\n      };\r\n    }\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\utils\\hateoas.ts",
    "messages": [
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 36,
        "column": 5,
        "nodeType": "MemberExpression",
        "endLine": 36,
        "endColumn": 20
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 113,
        "column": 5,
        "nodeType": "MemberExpression",
        "endLine": 113,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Request } from 'express';\r\n\r\nexport interface HateoasLink {\r\n  href: string;\r\n  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\r\n  rel: string;\r\n  type?: string;\r\n}\r\n\r\nexport interface HateoasResponse<T = unknown> {\r\n  data: T;\r\n  _links: Record<string, HateoasLink>;\r\n  _meta?: Record<string, unknown>;\r\n}\r\n\r\nexport interface PaginatedHateoasResponse<T = unknown> extends HateoasResponse<T[]> {\r\n  _meta: {\r\n    total: number;\r\n    page: number;\r\n    pageSize: number;\r\n    totalPages: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Helper to build HATEOAS links\r\n */\r\nexport class HateoasBuilder {\r\n  private links: Record<string, HateoasLink> = {};\r\n  private meta: Record<string, unknown> = {};\r\n\r\n  /**\r\n   * Add a link to the response\r\n   */\r\n  addLink(rel: string, href: string, method?: string, type?: string): this {\r\n    this.links[rel] = {\r\n      href,\r\n      rel,\r\n      method: method as HateoasLink['method'],\r\n      type,\r\n    };\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add self link\r\n   */\r\n  self(href: string): this {\r\n    return this.addLink('self', href, 'GET', 'application/json');\r\n  }\r\n\r\n  /**\r\n   * Add collection link\r\n   */\r\n  collection(href: string): this {\r\n    return this.addLink('collection', href, 'GET', 'application/json');\r\n  }\r\n\r\n  /**\r\n   * Add create link\r\n   */\r\n  create(href: string): this {\r\n    return this.addLink('create', href, 'POST', 'application/json');\r\n  }\r\n\r\n  /**\r\n   * Add update link\r\n   */\r\n  update(href: string): this {\r\n    return this.addLink('update', href, 'PUT', 'application/json');\r\n  }\r\n\r\n  /**\r\n   * Add delete link\r\n   */\r\n  delete(href: string): this {\r\n    return this.addLink('delete', href, 'DELETE');\r\n  }\r\n\r\n  /**\r\n   * Add pagination links\r\n   */\r\n  pagination(baseUrl: string, page: number, pageSize: number, total: number): this {\r\n    const totalPages = Math.ceil(total / pageSize);\r\n\r\n    // First page\r\n    if (page > 1) {\r\n      this.addLink('first', `${baseUrl}?page=1&pageSize=${pageSize}`, 'GET');\r\n    }\r\n\r\n    // Previous page\r\n    if (page > 1) {\r\n      this.addLink('prev', `${baseUrl}?page=${page - 1}&pageSize=${pageSize}`, 'GET');\r\n    }\r\n\r\n    // Next page\r\n    if (page < totalPages) {\r\n      this.addLink('next', `${baseUrl}?page=${page + 1}&pageSize=${pageSize}`, 'GET');\r\n    }\r\n\r\n    // Last page\r\n    if (page < totalPages) {\r\n      this.addLink('last', `${baseUrl}?page=${totalPages}&pageSize=${pageSize}`, 'GET');\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add metadata\r\n   */\r\n  addMeta(key: string, value: unknown): this {\r\n    this.meta[key] = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Build the HATEOAS response\r\n   */\r\n  build<T>(data: T): HateoasResponse<T> {\r\n    const response: HateoasResponse<T> = {\r\n      data,\r\n      _links: this.links,\r\n    };\r\n\r\n    if (Object.keys(this.meta).length > 0) {\r\n      response._meta = this.meta;\r\n    }\r\n\r\n    return response;\r\n  }\r\n\r\n  /**\r\n   * Build paginated HATEOAS response\r\n   */\r\n  buildPaginated<T>(\r\n    data: T[],\r\n    total: number,\r\n    page: number,\r\n    pageSize: number\r\n  ): PaginatedHateoasResponse<T> {\r\n    const totalPages = Math.ceil(total / pageSize);\r\n\r\n    return {\r\n      data,\r\n      _links: this.links,\r\n      _meta: {\r\n        total,\r\n        page,\r\n        pageSize,\r\n        totalPages,\r\n        ...this.meta,\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a HATEOAS response builder\r\n */\r\nexport function hateoas(): HateoasBuilder {\r\n  return new HateoasBuilder();\r\n}\r\n\r\n/**\r\n * Get base URL from request\r\n */\r\nexport function getBaseUrl(req: Request): string {\r\n  const protocol = req.protocol;\r\n  const host = req.get('host');\r\n  return `${protocol}://${host}`;\r\n}\r\n\r\n/**\r\n * Build full URL from request path\r\n */\r\nexport function buildUrl(req: Request, path?: string): string {\r\n  const baseUrl = getBaseUrl(req);\r\n  const resourcePath = path || req.originalUrl.split('?')[0];\r\n  return `${baseUrl}${resourcePath}`;\r\n}\r\n\r\n/**\r\n * Helper to create standard resource links\r\n */\r\nexport function createResourceLinks(\r\n  req: Request,\r\n  resourceId: string,\r\n  basePath: string\r\n): HateoasBuilder {\r\n  const baseUrl = getBaseUrl(req);\r\n\r\n  return hateoas()\r\n    .self(`${baseUrl}${basePath}/${resourceId}`)\r\n    .collection(`${baseUrl}${basePath}`)\r\n    .update(`${baseUrl}${basePath}/${resourceId}`)\r\n    .delete(`${baseUrl}${basePath}/${resourceId}`);\r\n}\r\n\r\n/**\r\n * Helper to create collection links with pagination\r\n */\r\nexport function createCollectionLinks(\r\n  req: Request,\r\n  basePath: string,\r\n  page: number,\r\n  pageSize: number,\r\n  total: number\r\n): HateoasBuilder {\r\n  const baseUrl = getBaseUrl(req);\r\n\r\n  return hateoas()\r\n    .self(buildUrl(req))\r\n    .create(`${baseUrl}${basePath}`)\r\n    .pagination(`${baseUrl}${basePath}`, page, pageSize, total);\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Development\\next-node-app-base\\apps\\backend\\src\\utils\\query-helpers.ts",
    "messages": [
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Variable Assigned to Object Injection Sink",
        "line": 118,
        "column": 26,
        "nodeType": "MemberExpression",
        "endLine": 118,
        "endColumn": 42
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 127,
        "column": 20,
        "nodeType": "MemberExpression",
        "endLine": 127,
        "endColumn": 33
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 157,
        "column": 64,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 157,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3461, 3464], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3461, 3464], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 159,
        "column": 16,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 159,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3547, 3550], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3547, 3550], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 167,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 167,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 171,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 171,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 175,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 175,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 179,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 179,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 183,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 183,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 187,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 187,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 191,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 191,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 195,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 195,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 199,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 199,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "security/detect-object-injection",
        "severity": 1,
        "message": "Generic Object Injection Sink",
        "line": 203,
        "column": 9,
        "nodeType": "MemberExpression",
        "endLine": 203,
        "endColumn": 21,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 242,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 242,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5993, 5996], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5993, 5996], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Request } from 'express';\nimport { z } from 'zod';\n\n/**\n * Standard pagination query parameters\n */\nexport const paginationSchema = z.object({\n  page: z\n    .string()\n    .optional()\n    .default('1')\n    .transform((val: string) => parseInt(val, 10))\n    .refine((val: number) => val > 0, { message: 'Page must be greater than 0' }),\n  pageSize: z\n    .string()\n    .optional()\n    .default('10')\n    .transform((val: string) => parseInt(val, 10))\n    .refine((val: number) => val > 0 && val <= 100, {\n      message: 'Page size must be between 1 and 100',\n    }),\n  sort: z.string().optional(),\n  order: z.enum(['asc', 'desc']).optional().default('asc'),\n});\n\nexport type PaginationParams = z.infer<typeof paginationSchema>;\n\n/**\n * Extract and validate pagination parameters from request\n */\nexport function getPaginationParams(req: Request): PaginationParams {\n  const result = paginationSchema.safeParse(req.query);\n\n  if (!result.success) {\n    throw new Error(`Invalid pagination parameters: ${result.error.message}`);\n  }\n\n  return result.data;\n}\n\n/**\n * Pagination metadata\n */\nexport interface PaginationMeta {\n  total: number;\n  page: number;\n  pageSize: number;\n  totalPages: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n\n/**\n * Calculate pagination metadata\n */\nexport function calculatePaginationMeta(\n  total: number,\n  page: number,\n  pageSize: number\n): PaginationMeta {\n  const totalPages = Math.ceil(total / pageSize);\n\n  return {\n    total,\n    page,\n    pageSize,\n    totalPages,\n    hasNextPage: page < totalPages,\n    hasPreviousPage: page > 1,\n  };\n}\n\n/**\n * Calculate skip and take for database queries\n */\nexport function getSkipTake(page: number, pageSize: number): { skip: number; take: number } {\n  return {\n    skip: (page - 1) * pageSize,\n    take: pageSize,\n  };\n}\n\n/**\n * Filtering helper\n */\nexport interface FilterParams {\n  field: string;\n  operator:\n    | 'eq'\n    | 'ne'\n    | 'gt'\n    | 'gte'\n    | 'lt'\n    | 'lte'\n    | 'in'\n    | 'contains'\n    | 'startsWith'\n    | 'endsWith';\n  value: unknown;\n}\n\n/**\n * Parse filter parameters from query string\n * Format: filter[field][operator]=value\n * Example: filter[name][contains]=john\n */\nexport function parseFilters(query: Record<string, unknown>): FilterParams[] {\n  const filters: FilterParams[] = [];\n\n  const filterValue = query['filter'];\n  if (!filterValue || typeof filterValue !== 'object' || filterValue === null) {\n    return filters;\n  }\n\n  const filterObj = filterValue as Record<string, unknown>;\n\n  Object.keys(filterObj).forEach((field) => {\n    const fieldFilters = filterObj[field];\n\n    if (fieldFilters && typeof fieldFilters === 'object') {\n      const ops = fieldFilters as Record<string, unknown>;\n      Object.keys(ops).forEach((operator) => {\n        if (isValidOperator(operator)) {\n          filters.push({\n            field,\n            operator: operator as FilterParams['operator'],\n            value: ops[operator],\n          });\n        }\n      });\n    }\n  });\n\n  return filters;\n}\n\nfunction isValidOperator(op: string): boolean {\n  return [\n    'eq',\n    'ne',\n    'gt',\n    'gte',\n    'lt',\n    'lte',\n    'in',\n    'contains',\n    'startsWith',\n    'endsWith',\n  ].includes(op);\n}\n\n/**\n * Convert filters to Prisma where clause\n * Note: Uses unknown for generic Prisma query building\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function filtersToPrismaWhere(filters: FilterParams[]): any {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const where: any = {};\n\n  filters.forEach((filter) => {\n    const { field, operator, value } = filter;\n\n    switch (operator) {\n      case 'eq':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = value;\n        break;\n      case 'ne':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = { not: value };\n        break;\n      case 'gt':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = { gt: value };\n        break;\n      case 'gte':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = { gte: value };\n        break;\n      case 'lt':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = { lt: value };\n        break;\n      case 'lte':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = { lte: value };\n        break;\n      case 'in':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = { in: Array.isArray(value) ? value : [value] };\n        break;\n      case 'contains':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = { contains: value, mode: 'insensitive' };\n        break;\n      case 'startsWith':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = { startsWith: value, mode: 'insensitive' };\n        break;\n      case 'endsWith':\n        // eslint-disable-next-line security/detect-object-injection\n        where[field] = { endsWith: value, mode: 'insensitive' };\n        break;\n    }\n  });\n\n  return where;\n}\n\n/**\n * Sorting helper\n */\nexport interface SortParams {\n  field: string;\n  order: 'asc' | 'desc';\n}\n\n/**\n * Parse sort parameters from query string\n * Format: sort=field1:asc,field2:desc\n */\nexport function parseSorting(sortQuery?: string): SortParams[] {\n  if (!sortQuery) {\n    return [];\n  }\n\n  return sortQuery.split(',').map((sortItem) => {\n    const [field, order = 'asc'] = sortItem.split(':');\n    return {\n      field: field?.trim() || '',\n      order: (order.toLowerCase() === 'desc' ? 'desc' : 'asc') as 'asc' | 'desc',\n    };\n  });\n}\n\n/**\n * Convert sort params to Prisma orderBy clause\n * Note: Uses any for generic Prisma query building\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function sortToPrismaOrderBy(sorts: SortParams[]): any {\n  if (sorts.length === 0) {\n    return undefined;\n  }\n\n  if (sorts.length === 1 && sorts[0]) {\n    return { [sorts[0].field]: sorts[0].order };\n  }\n\n  return sorts.map((sort) => ({ [sort.field]: sort.order }));\n}\n",
    "usedDeprecatedRules": []
  }
]
