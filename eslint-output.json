[{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\config\\multer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2409,2412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2409,2412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3293,3296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3293,3296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":117,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":117,"endColumn":38},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":135,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":135,"endColumn":36}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\r\nimport path from 'path';\r\n\r\nimport { Request } from 'express';\r\nimport multer, { FileFilterCallback } from 'multer';\r\n\r\n/**\r\n * Multer configuration for file uploads with security validations\r\n */\r\n\r\n// Maximum file sizes (in bytes)\r\nexport const MAX_FILE_SIZE = {\r\n  IMAGE: 5 * 1024 * 1024, // 5MB\r\n  VIDEO: 100 * 1024 * 1024, // 100MB\r\n  DOCUMENT: 10 * 1024 * 1024, // 10MB\r\n  DEFAULT: 5 * 1024 * 1024, // 5MB\r\n};\r\n\r\n// Allowed MIME types\r\nexport const ALLOWED_MIME_TYPES = {\r\n  IMAGES: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\r\n  DOCUMENTS: [\r\n    'application/pdf',\r\n    'application/msword',\r\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n  ],\r\n  VIDEOS: ['video/mp4', 'video/mpeg', 'video/quicktime'],\r\n  ALL: [\r\n    'image/jpeg',\r\n    'image/png',\r\n    'image/gif',\r\n    'image/webp',\r\n    'application/pdf',\r\n    'application/msword',\r\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n    'video/mp4',\r\n    'video/mpeg',\r\n    'video/quicktime',\r\n  ],\r\n};\r\n\r\n/**\r\n * Sanitize filename to prevent path traversal attacks\r\n */\r\nexport function sanitizeFilename(filename: string): string {\r\n  // Remove path traversal attempts\r\n  let sanitized = filename.replace(/\\.\\./g, '');\r\n\r\n  // Remove special characters except dot, dash, underscore\r\n  sanitized = sanitized.replace(/[^a-zA-Z0-9._-]/g, '_');\r\n\r\n  // Ensure filename doesn't start with dot (hidden file)\r\n  if (sanitized.startsWith('.')) {\r\n    sanitized = sanitized.substring(1);\r\n  }\r\n\r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Generate a unique filename\r\n */\r\nexport function generateUniqueFilename(originalname: string): string {\r\n  const timestamp = Date.now();\r\n  const random = crypto.randomBytes(8).toString('hex');\r\n  const ext = path.extname(originalname);\r\n  const basename = path.basename(originalname, ext);\r\n  const sanitizedBasename = sanitizeFilename(basename);\r\n\r\n  return `${timestamp}-${random}-${sanitizedBasename}${ext}`;\r\n}\r\n\r\n/**\r\n * Create a file filter function for Multer\r\n */\r\nexport function createFileFilter(allowedMimeTypes: string[]) {\r\n  return (_req: Request, file: Express.Multer.File, callback: FileFilterCallback) => {\r\n    // Check MIME type\r\n    if (!allowedMimeTypes.includes(file.mimetype)) {\r\n      return callback(\r\n        new Error(`Invalid file type. Allowed types: ${allowedMimeTypes.join(', ')}`) as any,\r\n        false\r\n      );\r\n    }\r\n\r\n    // Check file extension matches MIME type (basic validation)\r\n    const ext = path.extname(file.originalname).toLowerCase();\r\n    const validExtensions: Record<string, string[]> = {\r\n      'image/jpeg': ['.jpg', '.jpeg'],\r\n      'image/png': ['.png'],\r\n      'image/gif': ['.gif'],\r\n      'image/webp': ['.webp'],\r\n      'application/pdf': ['.pdf'],\r\n      'application/msword': ['.doc'],\r\n      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],\r\n      'video/mp4': ['.mp4'],\r\n      'video/mpeg': ['.mpeg', '.mpg'],\r\n      'video/quicktime': ['.mov'],\r\n    };\r\n\r\n    const allowedExtensions = validExtensions[file.mimetype];\r\n    if (allowedExtensions && !allowedExtensions.includes(ext)) {\r\n      return callback(\r\n        new Error(`File extension ${ext} does not match MIME type ${file.mimetype}`) as any,\r\n        false\r\n      );\r\n    }\r\n\r\n    callback(null, true);\r\n  };\r\n}\r\n\r\n/**\r\n * Configure Multer for memory storage (files stored as Buffers)\r\n * This is used when uploading to cloud storage providers\r\n */\r\nexport function configureMulterMemory(options?: {\r\n  maxFileSize?: number;\r\n  allowedMimeTypes?: string[];\r\n}) {\r\n  return multer({\r\n    storage: multer.memoryStorage(),\r\n    limits: {\r\n      fileSize: options?.maxFileSize || MAX_FILE_SIZE.DEFAULT,\r\n      files: 10, // Maximum 10 files per request\r\n    },\r\n    fileFilter: createFileFilter(options?.allowedMimeTypes || ALLOWED_MIME_TYPES.ALL),\r\n  });\r\n}\r\n\r\n/**\r\n * Configure Multer for disk storage (local filesystem)\r\n * This is used for local development or when using local storage provider\r\n */\r\nexport function configureMulterDisk(options?: {\r\n  destination?: string;\r\n  maxFileSize?: number;\r\n  allowedMimeTypes?: string[];\r\n}) {\r\n  return multer({\r\n    storage: multer.diskStorage({\r\n      destination: options?.destination || 'uploads/',\r\n      filename: (_req, file, callback) => {\r\n        const uniqueFilename = generateUniqueFilename(file.originalname);\r\n        callback(null, uniqueFilename);\r\n      },\r\n    }),\r\n    limits: {\r\n      fileSize: options?.maxFileSize || MAX_FILE_SIZE.DEFAULT,\r\n      files: 10,\r\n    },\r\n    fileFilter: createFileFilter(options?.allowedMimeTypes || ALLOWED_MIME_TYPES.ALL),\r\n  });\r\n}\r\n\r\n/**\r\n * Default Multer configuration (memory storage)\r\n */\r\nexport const upload = configureMulterMemory();\r\n\r\n/**\r\n * Multer configuration for images only\r\n */\r\nexport const uploadImage = configureMulterMemory({\r\n  maxFileSize: MAX_FILE_SIZE.IMAGE,\r\n  allowedMimeTypes: ALLOWED_MIME_TYPES.IMAGES,\r\n});\r\n\r\n/**\r\n * Multer configuration for documents only\r\n */\r\nexport const uploadDocument = configureMulterMemory({\r\n  maxFileSize: MAX_FILE_SIZE.DOCUMENT,\r\n  allowedMimeTypes: ALLOWED_MIME_TYPES.DOCUMENTS,\r\n});\r\n\r\n/**\r\n * Multer configuration for videos only\r\n */\r\nexport const uploadVideo = configureMulterMemory({\r\n  maxFileSize: MAX_FILE_SIZE.VIDEO,\r\n  allowedMimeTypes: ALLOWED_MIME_TYPES.VIDEOS,\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\config\\swagger.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":257,"column":3,"nodeType":"MemberExpression","messageId":"limited","endLine":257,"endColumn":14,"suggestions":[{"fix":{"range":[6041,6104],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":258,"column":3,"nodeType":"MemberExpression","messageId":"limited","endLine":258,"endColumn":14,"suggestions":[{"fix":{"range":[6107,6166],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Express } from 'express';\nimport swaggerJSDoc from 'swagger-jsdoc';\nimport swaggerUi from 'swagger-ui-express';\n\nconst swaggerDefinition = {\n  openapi: '3.0.0',\n  info: {\n    title: 'Next Node App Base API',\n    version: '1.0.0',\n    description: 'Production-ready API with OAuth, RBAC, and HATEOAS support',\n    contact: {\n      name: 'API Support',\n      email: 'support@example.com',\n    },\n    license: {\n      name: 'MIT',\n      url: 'https://opensource.org/licenses/MIT',\n    },\n  },\n  servers: [\n    {\n      url: 'http://localhost:3001/api',\n      description: 'Development server',\n    },\n    {\n      url: 'https://staging.example.com/api',\n      description: 'Staging server',\n    },\n    {\n      url: 'https://api.example.com/api',\n      description: 'Production server',\n    },\n  ],\n  components: {\n    securitySchemes: {\n      bearerAuth: {\n        type: 'http',\n        scheme: 'bearer',\n        bearerFormat: 'JWT',\n        description: 'JWT authorization header using the Bearer scheme',\n      },\n      oauth2: {\n        type: 'oauth2',\n        flows: {\n          authorizationCode: {\n            authorizationUrl: 'https://auth.example.com/oauth/authorize',\n            tokenUrl: 'https://auth.example.com/oauth/token',\n            scopes: {\n              'read:users': 'Read user information',\n              'write:users': 'Modify user information',\n              admin: 'Administrative access',\n            },\n          },\n        },\n      },\n    },\n    schemas: {\n      Error: {\n        type: 'object',\n        properties: {\n          error: {\n            type: 'string',\n            description: 'Error type',\n          },\n          message: {\n            type: 'string',\n            description: 'Error message',\n          },\n          details: {\n            type: 'object',\n            description: 'Additional error details',\n          },\n        },\n      },\n      HATEOASLink: {\n        type: 'object',\n        properties: {\n          href: {\n            type: 'string',\n            description: 'Link URL',\n          },\n          method: {\n            type: 'string',\n            enum: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],\n            description: 'HTTP method',\n          },\n          rel: {\n            type: 'string',\n            description: 'Link relation',\n          },\n          type: {\n            type: 'string',\n            description: 'Content type',\n          },\n        },\n      },\n      PaginationMeta: {\n        type: 'object',\n        properties: {\n          total: {\n            type: 'integer',\n            description: 'Total number of items',\n          },\n          page: {\n            type: 'integer',\n            description: 'Current page number',\n          },\n          pageSize: {\n            type: 'integer',\n            description: 'Number of items per page',\n          },\n          totalPages: {\n            type: 'integer',\n            description: 'Total number of pages',\n          },\n        },\n      },\n    },\n    parameters: {\n      PageParam: {\n        in: 'query',\n        name: 'page',\n        schema: {\n          type: 'integer',\n          minimum: 1,\n          default: 1,\n        },\n        description: 'Page number',\n      },\n      PageSizeParam: {\n        in: 'query',\n        name: 'pageSize',\n        schema: {\n          type: 'integer',\n          minimum: 1,\n          maximum: 100,\n          default: 10,\n        },\n        description: 'Number of items per page',\n      },\n      SortParam: {\n        in: 'query',\n        name: 'sort',\n        schema: {\n          type: 'string',\n        },\n        description: 'Sort field (e.g., \"createdAt:desc\")',\n      },\n      ApiVersionHeader: {\n        in: 'header',\n        name: 'Accept',\n        schema: {\n          type: 'string',\n          example: 'application/vnd.api+json; version=1.0',\n        },\n        description: 'API version header',\n      },\n    },\n    responses: {\n      UnauthorizedError: {\n        description: 'Authentication required',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n      ForbiddenError: {\n        description: 'Insufficient permissions',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n      NotFoundError: {\n        description: 'Resource not found',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n      ValidationError: {\n        description: 'Validation error',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n    },\n  },\n  security: [\n    {\n      bearerAuth: [],\n    },\n  ],\n  tags: [\n    {\n      name: 'Authentication',\n      description: 'Authentication and authorization endpoints',\n    },\n    {\n      name: 'Users',\n      description: 'User management endpoints',\n    },\n    {\n      name: 'Health',\n      description: 'Health check endpoints',\n    },\n  ],\n};\n\nconst swaggerOptions: swaggerJSDoc.Options = {\n  swaggerDefinition,\n  apis: [\n    './src/routes/*.ts',\n    './src/controllers/*.ts',\n    './src/routes/**/*.ts',\n    './src/controllers/**/*.ts',\n  ],\n};\n\nexport const swaggerSpec = swaggerJSDoc(swaggerOptions);\n\n/**\n * Configure Swagger UI middleware\n */\nexport function setupSwagger(app: Express): void {\n  // Swagger UI\n  app.use(\n    '/api-docs',\n    swaggerUi.serve,\n    swaggerUi.setup(swaggerSpec, {\n      customCss: '.swagger-ui .topbar { display: none }',\n      customSiteTitle: 'Next Node App Base API Documentation',\n      customfavIcon: '/favicon.ico',\n      explorer: true,\n    })\n  );\n\n  // OpenAPI spec endpoint\n  app.get('/api-docs.json', (_req, res) => {\n    res.setHeader('Content-Type', 'application/json');\n    res.send(swaggerSpec);\n  });\n\n  console.log('­ƒôÜ Swagger documentation available at /api-docs');\n  console.log('­ƒôä OpenAPI spec available at /api-docs.json');\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\container.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\controllers\\user.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\middleware\\api-version.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1250,1253],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1250,1253],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1612,1615],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1612,1615],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":78,"column":18,"nodeType":"MemberExpression","endLine":78,"endColumn":27},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":79,"column":18,"nodeType":"MemberExpression","endLine":79,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2528,2531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2528,2531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextFunction, Request, Response } from 'express';\n\nexport interface ApiVersionMiddlewareOptions {\n  defaultVersion?: string;\n  supportedVersions?: string[];\n  header?: string;\n}\n\n/**\n * Middleware to extract and validate API version from headers\n * Version format: application/vnd.api+json; version=1.0\n */\nexport function apiVersionMiddleware(options: ApiVersionMiddlewareOptions = {}) {\n  const { defaultVersion = '1.0', supportedVersions = ['1.0'], header = 'accept' } = options;\n\n  return (req: Request, res: Response, next: NextFunction): void => {\n    let version = defaultVersion;\n\n    const acceptHeader = req.get(header);\n    if (acceptHeader) {\n      // Extract version from Accept header\n      const versionMatch = acceptHeader.match(/version=([0-9.]+)/);\n      if (versionMatch && versionMatch[1]) {\n        version = versionMatch[1];\n      }\n    }\n\n    // Check if version is supported\n    if (!supportedVersions.includes(version)) {\n      res.status(400).json({\n        error: 'Unsupported API version',\n        message: `API version ${version} is not supported. Supported versions: ${supportedVersions.join(', ')}`,\n        supportedVersions,\n      });\n      return;\n    }\n\n    // Attach version to request object\n    (req as any).apiVersion = version;\n\n    // Set version in response header\n    res.setHeader('API-Version', version);\n\n    next();\n  };\n}\n\n/**\n * Helper to check if request is for a specific version or higher\n */\nexport function requireVersion(minVersion: string) {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    const currentVersion = (req as any).apiVersion || '1.0';\n\n    if (compareVersions(currentVersion, minVersion) < 0) {\n      res.status(400).json({\n        error: 'API version too old',\n        message: `This endpoint requires API version ${minVersion} or higher`,\n        currentVersion,\n        requiredVersion: minVersion,\n      });\n      return;\n    }\n\n    next();\n  };\n}\n\n/**\n * Compare two semantic version strings\n * Returns: -1 if a < b, 0 if a === b, 1 if a > b\n */\nfunction compareVersions(a: string, b: string): number {\n  const aParts = a.split('.').map(Number);\n  const bParts = b.split('.').map(Number);\n\n  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    const aNum = aParts[i] || 0;\n    const bNum = bParts[i] || 0;\n\n    if (aNum > bNum) return 1;\n    if (aNum < bNum) return -1;\n  }\n\n  return 0;\n}\n\n/**\n * Get API version from request\n */\nexport function getApiVersion(req: Request): string {\n  return (req as any).apiVersion || '1.0';\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\middleware\\auth.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":11,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":15,"endColumn":4},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_error' is defined but never used.","line":40,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":18}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TokenPayload } from '@repo/types';\nimport { NextFunction, Request, Response } from 'express';\nimport { container } from 'tsyringe';\n\nimport { AuthorizationService } from '../services/auth/authorization.service';\nimport { JwtService } from '../services/auth/jwt.service';\n\n// Extend Express Request to include user\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: TokenPayload;\n    }\n  }\n}\n\n/**\n * Middleware to authenticate JWT token\n */\nexport const authenticate = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n    if (!token) {\n      res.status(401).json({ error: 'No token provided' });\n      return;\n    }\n\n    const jwtService = container.resolve(JwtService);\n    const payload = await jwtService.validateAccessToken(token);\n\n    req.user = payload;\n    next();\n  } catch (_error) {\n    res.status(403).json({ error: 'Invalid or expired token' });\n  }\n};\n\n/**\n * Middleware factory to check for required roles\n */\nexport const requireRole = (...roles: string[]) => {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    if (!req.user) {\n      res.status(401).json({ error: 'Unauthorized' });\n      return;\n    }\n\n    const authService = container.resolve(AuthorizationService);\n    const userId = req.user['userId'];\n\n    for (const role of roles) {\n      const hasRole = await authService.hasRole(userId, role);\n      if (hasRole) {\n        next();\n        return;\n      }\n    }\n\n    res\n      .status(403)\n      .json({ error: 'Insufficient permissions - required roles: ' + roles.join(', ') });\n  };\n};\n\n/**\n * Middleware factory to check for required permissions\n */\nexport const requirePermission = (...permissions: string[]) => {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    if (!req.user) {\n      res.status(401).json({ error: 'Unauthorized' });\n      return;\n    }\n\n    const authService = container.resolve(AuthorizationService);\n    const userId = req.user['userId'];\n\n    for (const permission of permissions) {\n      const hasPermission = await authService.hasPermission(userId, permission);\n      if (!hasPermission) {\n        res\n          .status(403)\n          .json({ error: 'Insufficient permissions - required: ' + permissions.join(', ') });\n        return;\n      }\n    }\n\n    next();\n  };\n};\n\n/**\n * Middleware factory to check resource access\n */\nexport const requireAccess = (resource: string, action: string) => {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    if (!req.user) {\n      res.status(401).json({ error: 'Unauthorized' });\n      return;\n    }\n\n    const authService = container.resolve(AuthorizationService);\n    const userId = req.user['userId'];\n\n    const canAccess = await authService.canAccess(userId, resource, action);\n\n    if (!canAccess) {\n      res.status(403).json({ error: `Access denied for ${action} on ${resource}` });\n      return;\n    }\n\n    next();\n  };\n};\n\n/**\n * Optional authentication - sets user if token is valid but doesn't fail if not\n */\nexport const optionalAuth = async (\n  req: Request,\n  _res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];\n\n    if (token) {\n      const jwtService = container.resolve(JwtService);\n      const payload = await jwtService.validateAccessToken(token);\n      req.user = payload;\n    }\n  } catch {\n    // Ignore errors - authentication is optional\n  }\n\n  next();\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\middleware\\security.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\repositories\\user.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\routes\\files.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\routes\\user.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\routes\\users-v2.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2578,2581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2578,2581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5665,5668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5665,5668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Router, type NextFunction, type Request, type Response } from 'express';\r\nimport { container } from 'tsyringe';\r\n\r\nimport { AuthorizationService } from '../services/auth/authorization.service';\r\nimport { DatabaseService } from '../services/database.service';\r\nimport { createCollectionLinks, createResourceLinks } from '../utils/hateoas';\r\nimport {\r\n  filtersToPrismaWhere,\r\n  getPaginationParams,\r\n  getSkipTake,\r\n  parseFilters,\r\n  parseSorting,\r\n  sortToPrismaOrderBy,\r\n} from '../utils/query-helpers';\r\n\r\nconst router: import('express').Router = Router();\r\n\r\n/**\r\n * @swagger\r\n * /api/users:\r\n *   get:\r\n *     summary: List all users with pagination\r\n *     description: Retrieve a paginated list of users with filtering and sorting\r\n *     tags: [Users]\r\n *     security:\r\n *       - bearerAuth: []\r\n *     parameters:\r\n *       - $ref: '#/components/parameters/PageParam'\r\n *       - $ref: '#/components/parameters/PageSizeParam'\r\n *       - $ref: '#/components/parameters/SortParam'\r\n *       - $ref: '#/components/parameters/ApiVersionHeader'\r\n *       - in: query\r\n *         name: filter[role][eq]\r\n *         schema:\r\n *           type: string\r\n *           enum: [USER, ADMIN]\r\n *         description: Filter by role\r\n *       - in: query\r\n *         name: filter[email][contains]\r\n *         schema:\r\n *           type: string\r\n *         description: Filter by email (case-insensitive)\r\n *     responses:\r\n *       200:\r\n *         description: Successful response\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 data:\r\n *                   type: array\r\n *                   items:\r\n *                     $ref: '#/components/schemas/User'\r\n *                 _links:\r\n *                   type: object\r\n *                   additionalProperties:\r\n *                     $ref: '#/components/schemas/HATEOASLink'\r\n *                 _meta:\r\n *                   $ref: '#/components/schemas/PaginationMeta'\r\n *       401:\r\n *         $ref: '#/components/responses/UnauthorizedError'\r\n *       403:\r\n *         $ref: '#/components/responses/ForbiddenError'\r\n */\r\n// @ts-expect-error TS7030 - TypeScript doesn't recognize res.json() and next() as terminal statements\r\nrouter.get('/', async (req: Request, res: Response, next: NextFunction) => {\r\n  try {\r\n    const db = container.resolve(DatabaseService);\r\n    const authz = container.resolve<AuthorizationService>('AuthorizationService');\r\n\r\n    // Check authorization\r\n    const userId = (req as any).user?.id;\r\n    if (!userId) {\r\n      return res.status(401).json({ error: 'Unauthorized' });\r\n    }\r\n\r\n    const hasPermission = await authz.hasPermission(userId, 'users:read');\r\n    if (!hasPermission) {\r\n      return res.status(403).json({ error: 'Forbidden' });\r\n    }\r\n\r\n    // Parse query parameters\r\n    const { page, pageSize, sort } = getPaginationParams(req);\r\n    const filters = parseFilters(req.query);\r\n    const sorting = parseSorting(sort);\r\n    const { skip, take } = getSkipTake(page, pageSize);\r\n\r\n    // Build Prisma where clause\r\n    const where = filtersToPrismaWhere(filters);\r\n\r\n    // Build Prisma orderBy clause\r\n    const orderBy = sortToPrismaOrderBy(\r\n      sorting.length > 0 ? sorting : [{ field: 'createdAt', order: 'desc' }]\r\n    );\r\n\r\n    // Fetch users with pagination\r\n    const [users, total] = await Promise.all([\r\n      db.user.findMany({\r\n        where,\r\n        skip,\r\n        take,\r\n        orderBy,\r\n        select: {\r\n          id: true,\r\n          email: true,\r\n          name: true,\r\n          role: true,\r\n          createdAt: true,\r\n          updatedAt: true,\r\n          lastLoginAt: true,\r\n        },\r\n      }),\r\n      db.user.count({ where }),\r\n    ]);\r\n\r\n    // Add HATEOAS links to each user\r\n    const usersWithLinks = users.map((user) =>\r\n      createResourceLinks(req, user.id, '/api/users').build(user)\r\n    );\r\n\r\n    // Build paginated response with collection links\r\n    const response = createCollectionLinks(req, '/api/users', page, pageSize, total).buildPaginated(\r\n      usersWithLinks,\r\n      total,\r\n      page,\r\n      pageSize\r\n    );\r\n\r\n    res.json(response);\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n});\r\n\r\n/**\r\n * @swagger\r\n * /api/users/{id}:\r\n *   get:\r\n *     summary: Get user by ID\r\n *     description: Retrieve detailed information about a specific user\r\n *     tags: [Users]\r\n *     security:\r\n *       - bearerAuth: []\r\n *     parameters:\r\n *       - in: path\r\n *         name: id\r\n *         required: true\r\n *         schema:\r\n *           type: string\r\n *         description: User ID\r\n *       - $ref: '#/components/parameters/ApiVersionHeader'\r\n *     responses:\r\n *       200:\r\n *         description: Successful response\r\n *         content:\r\n *           application/json:\r\n *             schema:\r\n *               type: object\r\n *               properties:\r\n *                 data:\r\n *                   $ref: '#/components/schemas/User'\r\n *                 _links:\r\n *                   type: object\r\n *                   additionalProperties:\r\n *                     $ref: '#/components/schemas/HATEOASLink'\r\n *       401:\r\n *         $ref: '#/components/responses/UnauthorizedError'\r\n *       403:\r\n *         $ref: '#/components/responses/ForbiddenError'\r\n *       404:\r\n *         $ref: '#/components/responses/NotFoundError'\r\n */\r\nrouter.get('/:id', async (req: Request, res: Response, next: NextFunction) => {\r\n  try {\r\n    const db = container.resolve(DatabaseService);\r\n    const authz = container.resolve<AuthorizationService>('AuthorizationService');\r\n\r\n    const userId = (req as any).user?.id;\r\n    if (!userId) {\r\n      res.status(401).json({ error: 'Unauthorized' });\r\n      return;\r\n    }\r\n\r\n    const hasPermission = await authz.hasPermission(userId, 'users:read');\r\n    if (!hasPermission) {\r\n      res.status(403).json({ error: 'Forbidden' });\r\n      return;\r\n    }\r\n\r\n    const user = await db.user.findUnique({\r\n      where: { id: req.params['id'] },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        role: true,\r\n        createdAt: true,\r\n        updatedAt: true,\r\n        lastLoginAt: true,\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      res.status(404).json({\r\n        error: 'Not Found',\r\n        message: 'User not found',\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Build HATEOAS response\r\n    const response = createResourceLinks(req, user.id, '/api/users').build(user);\r\n\r\n    res.json(response);\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n});\r\n\r\n/**\r\n * @swagger\r\n * components:\r\n *   schemas:\r\n *     User:\r\n *       type: object\r\n *       properties:\r\n *         id:\r\n *           type: string\r\n *           description: User unique identifier\r\n *         email:\r\n *           type: string\r\n *           format: email\r\n *           description: User email address\r\n *         name:\r\n *           type: string\r\n *           description: User full name\r\n *         role:\r\n *           type: string\r\n *           enum: [USER, ADMIN]\r\n *           description: User role\r\n *         createdAt:\r\n *           type: string\r\n *           format: date-time\r\n *           description: Account creation timestamp\r\n *         updatedAt:\r\n *           type: string\r\n *           format: date-time\r\n *           description: Last update timestamp\r\n *         lastLoginAt:\r\n *           type: string\r\n *           format: date-time\r\n *           description: Last login timestamp\r\n */\r\n\r\nexport const usersRouter = router;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\routes\\users.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[694,697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[694,697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":63,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1834,1837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1834,1837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2888,2891],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2888,2891],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3430,3433],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3430,3433],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4496,4499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4496,4499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":188,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":188,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5052,5055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5052,5055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":219,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5786,5789],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5786,5789],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Router, type Request, type Response } from 'express';\r\nimport { container } from 'tsyringe';\r\n\r\nimport { AuditLogService } from '../services/audit/audit-log.service';\r\nimport { AuthorizationService } from '../services/auth/authorization.service';\r\nimport { DatabaseService } from '../services/database.service';\r\n\r\nconst router: import('express').Router = Router();\r\n\r\n/**\r\n * Get all users (admin only)\r\n */\r\nrouter.get('/', async (req: Request, res: Response): Promise<void> => {\r\n  try {\r\n    const db = container.resolve(DatabaseService);\r\n    const authz = container.resolve<AuthorizationService>('AuthorizationService');\r\n\r\n    // Check authorization\r\n    const userId = (req as any).user?.id;\r\n    if (!userId) {\r\n      res.status(401).json({ error: 'Unauthorized' });\r\n      return;\r\n    }\r\n\r\n    const hasPermission = await authz.hasPermission(userId, 'users:read');\r\n    if (!hasPermission) {\r\n      res.status(403).json({ error: 'Forbidden' });\r\n      return;\r\n    }\r\n\r\n    const users = await db.user.findMany({\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        role: true,\r\n        createdAt: true,\r\n        updatedAt: true,\r\n        lastLoginAt: true,\r\n      },\r\n      orderBy: {\r\n        createdAt: 'desc',\r\n      },\r\n    });\r\n\r\n    res.json(users);\r\n    return;\r\n  } catch (error) {\r\n    console.error('Error fetching users:', error);\r\n    res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n});\r\n\r\n/**\r\n * Get single user by ID\r\n */\r\nrouter.get('/:id', async (req: Request, res: Response): Promise<void> => {\r\n  try {\r\n    const db = container.resolve(DatabaseService);\r\n    const authz = container.resolve<AuthorizationService>('AuthorizationService');\r\n    const audit = container.resolve<AuditLogService>('AuditLogService');\r\n\r\n    const userId = (req as any).user?.id;\r\n    const { id } = req.params;\r\n\r\n    if (!userId) {\r\n      res.status(401).json({ error: 'Unauthorized' });\r\n      return;\r\n    }\r\n\r\n    // Users can view their own profile, admins can view anyone\r\n    const isOwnProfile = userId === id;\r\n    const hasPermission = await authz.hasPermission(userId, 'users:read');\r\n\r\n    if (!isOwnProfile && !hasPermission) {\r\n      res.status(403).json({ error: 'Forbidden' });\r\n      return;\r\n    }\r\n\r\n    const user = await db.user.findUnique({\r\n      where: { id },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        image: true,\r\n        role: true,\r\n        createdAt: true,\r\n        updatedAt: true,\r\n        lastLoginAt: true,\r\n        profile: true,\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      res.status(404).json({ error: 'User not found' });\r\n      return;\r\n    }\r\n\r\n    await audit.log({\r\n      userId,\r\n      action: 'READ',\r\n      resource: 'user',\r\n      resourceId: id,\r\n      ipAddress: req.ip,\r\n      userAgent: req.get('user-agent'),\r\n    } as any);\r\n\r\n    res.json(user);\r\n    return;\r\n  } catch (error) {\r\n    console.error('Error fetching user:', error);\r\n    res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n});\r\n\r\n/**\r\n * Update user\r\n */\r\nrouter.patch('/:id', async (req: Request, res: Response): Promise<void> => {\r\n  try {\r\n    const db = container.resolve(DatabaseService);\r\n    const authz = container.resolve<AuthorizationService>('AuthorizationService');\r\n    const audit = container.resolve<AuditLogService>('AuditLogService');\r\n\r\n    const userId = (req as any).user?.id;\r\n    const { id } = req.params;\r\n    const { name, image } = req.body;\r\n\r\n    if (!userId) {\r\n      res.status(401).json({ error: 'Unauthorized' });\r\n      return;\r\n    }\r\n\r\n    // Users can update their own profile, admins can update anyone\r\n    const isOwnProfile = userId === id;\r\n    const hasPermission = await authz.hasPermission(userId, 'users:update');\r\n\r\n    if (!isOwnProfile && !hasPermission) {\r\n      res.status(403).json({ error: 'Forbidden' });\r\n      return;\r\n    }\r\n\r\n    const user = await db.user.update({\r\n      where: { id },\r\n      data: {\r\n        name,\r\n        image,\r\n        updatedAt: new Date(),\r\n      },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        image: true,\r\n        role: true,\r\n        updatedAt: true,\r\n      },\r\n    });\r\n\r\n    await audit.log({\r\n      userId,\r\n      action: 'UPDATE',\r\n      resource: 'user',\r\n      resourceId: id,\r\n      ipAddress: req.ip,\r\n      userAgent: req.get('user-agent'),\r\n      metadata: { fields: Object.keys({ name, image }) },\r\n    } as any);\r\n\r\n    res.json(user);\r\n    return;\r\n  } catch (error) {\r\n    console.error('Error updating user:', error);\r\n    res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n});\r\n\r\n/**\r\n * Delete user (admin only)\r\n */\r\nrouter.delete('/:id', async (req: Request, res: Response): Promise<void> => {\r\n  try {\r\n    const db = container.resolve(DatabaseService);\r\n    const authz = container.resolve<AuthorizationService>('AuthorizationService');\r\n    const audit = container.resolve<AuditLogService>('AuditLogService');\r\n\r\n    const userId = (req as any).user?.id;\r\n    const { id } = req.params;\r\n\r\n    if (!userId) {\r\n      res.status(401).json({ error: 'Unauthorized' });\r\n      return;\r\n    }\r\n\r\n    const hasPermission = await authz.hasPermission(userId, 'users:delete');\r\n    if (!hasPermission) {\r\n      res.status(403).json({ error: 'Forbidden' });\r\n      return;\r\n    }\r\n\r\n    // Prevent self-deletion\r\n    if (userId === id) {\r\n      res.status(400).json({ error: 'Cannot delete your own account' });\r\n      return;\r\n    }\r\n\r\n    await db.user.delete({\r\n      where: { id },\r\n    });\r\n\r\n    await audit.log({\r\n      userId,\r\n      action: 'DELETE',\r\n      resource: 'user',\r\n      resourceId: id,\r\n      ipAddress: req.ip,\r\n      userAgent: req.get('user-agent'),\r\n    } as any);\r\n\r\n    res.status(204).send();\r\n    return;\r\n  } catch (error) {\r\n    console.error('Error deleting user:', error);\r\n    res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n});\r\n\r\nexport default router;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\security\\interfaces.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[71,74],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[71,74],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[85,88],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[85,88],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[131,134],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[131,134],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[190,193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[190,193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[475,478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[475,478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[503,506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[503,506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[543,546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[543,546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1181,1184],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1181,1184],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1271,1274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1271,1274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1285,1288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1285,1288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1417,1420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1417,1420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1465,1468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1465,1468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface IAuthenticationProvider {\n  authenticate(credentials: any): Promise<any>;\n  validateToken(token: string): Promise<any | null>;\n  refreshToken(refreshToken: string): Promise<any>;\n}\n\nexport interface IEncryptionService {\n  encrypt(data: string): Promise<string>;\n  decrypt(data: string): Promise<string>;\n  hash(data: string): Promise<string>;\n  compareHash(data: string, hash: string): Promise<boolean>;\n}\n\nexport interface IStorageProvider {\n  upload(file: any, path: string): Promise<any>;\n  download(path: string): Promise<any>;\n  delete(path: string): Promise<void>;\n  getSignedUrl(path: string, expiresIn: number): Promise<string>;\n}\n\nexport interface INotificationService {\n  sendEmail(to: string, subject: string, body: string): Promise<void>;\n  sendSMS(to: string, message: string): Promise<void>;\n  sendPushNotification(userId: string, message: string): Promise<void>;\n}\n\nexport interface ISecretsManager {\n  getSecret(key: string): Promise<string>;\n  setSecret(key: string, value: string): Promise<void>;\n  deleteSecret(key: string): Promise<void>;\n}\n\nexport interface IWebhookService {\n  register(url: string, events: string[], secret: string): Promise<any>;\n  unregister(webhookId: string): Promise<void>;\n  deliver(webhookId: string, event: any): Promise<any>;\n  verifySignature(payload: string, signature: string, secret: string): boolean;\n}\n\nexport interface ICacheService {\n  get<T = any>(key: string): Promise<T | null>;\n  set<T = any>(key: string, value: T, ttl?: number): Promise<void>;\n  delete(key: string): Promise<void>;\n  invalidate(pattern: string): Promise<void>;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\audit\\audit-log.service.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":69,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":69,"endColumn":16,"suggestions":[{"fix":{"range":[1763,1812],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2415,2418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2415,2418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { injectable } from 'tsyringe';\n\nexport interface AuditLogEntry {\n  timestamp: Date;\n  userId?: string;\n  action: string;\n  resource: string;\n  resourceId?: string;\n  ipAddress?: string;\n  userAgent?: string;\n  success: boolean;\n  errorMessage?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport enum AuditAction {\n  // Authentication\n  LOGIN = 'auth.login',\n  LOGOUT = 'auth.logout',\n  LOGIN_FAILED = 'auth.login_failed',\n  TOKEN_REFRESH = 'auth.token_refresh',\n  PASSWORD_CHANGE = 'auth.password_change',\n  PASSWORD_RESET = 'auth.password_reset',\n\n  // Authorization\n  ACCESS_GRANTED = 'authz.access_granted',\n  ACCESS_DENIED = 'authz.access_denied',\n  ROLE_ASSIGNED = 'authz.role_assigned',\n  ROLE_REVOKED = 'authz.role_revoked',\n  PERMISSION_GRANTED = 'authz.permission_granted',\n  PERMISSION_REVOKED = 'authz.permission_revoked',\n\n  // Data operations\n  CREATE = 'data.create',\n  READ = 'data.read',\n  UPDATE = 'data.update',\n  DELETE = 'data.delete',\n\n  // Security events\n  ENCRYPTION_KEY_ROTATION = 'security.key_rotation',\n  SECRET_ACCESS = 'security.secret_access',\n  SUSPICIOUS_ACTIVITY = 'security.suspicious_activity',\n}\n\n/**\n * Audit logging service for security events\n * In production, this would write to a secure audit log storage\n */\n@injectable()\nexport class AuditLogService {\n  private logs: AuditLogEntry[] = [];\n\n  /**\n   * Log security event\n   */\n  async log(entry: Omit<AuditLogEntry, 'timestamp'>): Promise<void> {\n    const logEntry: AuditLogEntry = {\n      ...entry,\n      timestamp: new Date(),\n    };\n\n    this.logs.push(logEntry);\n\n    // In production:\n    // - Write to database with retention policy\n    // - Send to SIEM system\n    // - Trigger alerts for critical events\n    // - Ensure immutability of logs\n    console.log('[AUDIT]', JSON.stringify(logEntry));\n  }\n\n  /**\n   * Log authentication event\n   */\n  async logAuth(params: {\n    userId?: string;\n    action: AuditAction;\n    success: boolean;\n    ipAddress?: string;\n    userAgent?: string;\n    errorMessage?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<void> {\n    await this.log({\n      ...params,\n      resource: 'authentication',\n    });\n  }\n\n  /**\n   * Log authorization event\n   */\n  async logAuthz(params: {\n    userId: string;\n    action: AuditAction;\n    resource: string;\n    resourceId?: string;\n    success: boolean;\n    errorMessage?: string;\n    metadata?: Record<string, any>;\n  }): Promise<void> {\n    await this.log({\n      ...params,\n    });\n  }\n\n  /**\n   * Log data access event\n   */\n  async logDataAccess(params: {\n    userId: string;\n    action: AuditAction;\n    resource: string;\n    resourceId?: string;\n    success: boolean;\n    metadata?: Record<string, unknown>;\n  }): Promise<void> {\n    await this.log({\n      ...params,\n    });\n  }\n\n  /**\n   * Log security event\n   */\n  async logSecurityEvent(params: {\n    userId?: string;\n    action: AuditAction;\n    resource: string;\n    success: boolean;\n    errorMessage?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<void> {\n    await this.log({\n      ...params,\n    });\n  }\n\n  /**\n   * Clear in-memory logs (test helper)\n   */\n  clear(): void {\n    this.logs.length = 0;\n  }\n\n  /**\n   * Get audit logs (with pagination and filtering)\n   * In production, this would query from persistent storage\n   */\n  async getLogs(filter?: {\n    userId?: string;\n    action?: string;\n    resource?: string;\n    startDate?: Date;\n    endDate?: Date;\n    limit?: number;\n  }): Promise<AuditLogEntry[]> {\n    let filtered = this.logs;\n\n    if (filter?.userId) {\n      filtered = filtered.filter((log) => log.userId === filter.userId);\n    }\n\n    if (filter?.action) {\n      filtered = filtered.filter((log) => log.action === filter.action);\n    }\n\n    if (filter?.resource) {\n      filtered = filtered.filter((log) => log.resource === filter.resource);\n    }\n\n    if (filter?.startDate) {\n      const startDate = filter.startDate;\n      filtered = filtered.filter((log) => log.timestamp >= startDate);\n    }\n\n    if (filter?.endDate) {\n      const endDate = filter.endDate;\n      filtered = filtered.filter((log) => log.timestamp <= endDate);\n    }\n\n    if (filter?.limit) {\n      filtered = filtered.slice(0, filter.limit);\n    }\n\n    return filtered;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\authorization.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\encryption.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\jwt.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_error' is defined but never used.","line":59,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":59,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_error' is defined but never used.","line":71,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":71,"endColumn":20},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":104,"column":21,"nodeType":"MemberExpression","endLine":104,"endColumn":38}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TokenPayload, TokenResult } from '@repo/types';\nimport jwt from 'jsonwebtoken';\nimport { injectable } from 'tsyringe';\n\n@injectable()\nexport class JwtService {\n  private readonly accessTokenSecret: string;\n  private readonly refreshTokenSecret: string;\n  private readonly accessTokenExpiry: string;\n  private readonly refreshTokenExpiry: string;\n\n  constructor() {\n    this.accessTokenSecret = process.env['JWT_ACCESS_SECRET'] || 'access-secret-change-me';\n    this.refreshTokenSecret = process.env['JWT_REFRESH_SECRET'] || 'refresh-secret-change-me';\n    this.accessTokenExpiry = process.env['JWT_ACCESS_EXPIRY'] || '15m';\n    this.refreshTokenExpiry = process.env['JWT_REFRESH_EXPIRY'] || '7d';\n  }\n\n  /**\n   * Generate access token\n   */\n  generateAccessToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {\n    return jwt.sign(payload, this.accessTokenSecret, {\n      expiresIn: this.accessTokenExpiry,\n    } as jwt.SignOptions);\n  }\n\n  /**\n   * Generate refresh token\n   */\n  generateRefreshToken(userId: string): string {\n    return jwt.sign({ userId }, this.refreshTokenSecret, {\n      expiresIn: this.refreshTokenExpiry,\n    } as jwt.SignOptions);\n  }\n\n  /**\n   * Generate both access and refresh tokens\n   */\n  generateTokens(payload: Omit<TokenPayload, 'iat' | 'exp'>): TokenResult {\n    const accessToken = this.generateAccessToken(payload);\n    const refreshToken = this.generateRefreshToken(payload['userId']);\n\n    return {\n      accessToken,\n      refreshToken,\n      expiresIn: this.parseExpiry(this.accessTokenExpiry),\n      tokenType: 'Bearer',\n    };\n  }\n\n  /**\n   * Validate access token\n   */\n  async validateAccessToken(token: string): Promise<TokenPayload> {\n    try {\n      const decoded = jwt.verify(token, this.accessTokenSecret) as TokenPayload;\n      return decoded;\n    } catch (_error) {\n      throw new Error('Invalid or expired access token');\n    }\n  }\n\n  /**\n   * Validate refresh token\n   */\n  async validateRefreshToken(token: string): Promise<{ userId: string }> {\n    try {\n      const decoded = jwt.verify(token, this.refreshTokenSecret) as { userId: string };\n      return decoded;\n    } catch (_error) {\n      throw new Error('Invalid or expired refresh token');\n    }\n  }\n\n  /**\n   * Decode token without validation (for inspection)\n   */\n  decodeToken(token: string): TokenPayload | null {\n    try {\n      return jwt.decode(token) as TokenPayload;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Parse expiry string to seconds\n   */\n  private parseExpiry(expiry: string): number {\n    const match = expiry.match(/^(\\d+)([smhd])$/);\n    if (!match || !match[1] || !match[2]) return 900; // default 15 minutes\n\n    const value = parseInt(match[1], 10);\n    const unit = match[2];\n\n    const multipliers: Record<string, number> = {\n      s: 1,\n      m: 60,\n      h: 3600,\n      d: 86400,\n    };\n\n    return value * (multipliers[unit] || 60);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\policy-engine.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":254,"column":102,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":105,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7164,7167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7164,7167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":255,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7222,7225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7222,7225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":269,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7622,7625],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7622,7625],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":273,"column":17,"nodeType":"MemberExpression","endLine":273,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":285,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7931,7934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7931,7934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":285,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7976,7979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7976,7979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"security/detect-non-literal-regexp","severity":1,"message":"Found non-literal argument to RegExp Constructor","line":323,"column":27,"nodeType":"NewExpression","endLine":323,"endColumn":47}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  ComparisonOperator,\r\n  Condition,\r\n  IPolicyEngine,\r\n  LogicalCondition,\r\n  LogicalOperator,\r\n  Policy,\r\n  PolicyContext,\r\n  PolicyEffect,\r\n  PolicyEvaluationResult,\r\n  PolicyRule,\r\n} from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\n/**\r\n * Policy evaluation engine for ABAC\r\n * Evaluates policies and conditions against a given context\r\n */\r\n@injectable()\r\nexport class PolicyEngine implements IPolicyEngine {\r\n  /**\r\n   * Evaluate all applicable policies for a given context\r\n   * Uses deny-overrides strategy: if any policy denies, access is denied\r\n   * @deprecated Use evaluatePolicies instead - this method requires policies to be passed in\r\n   */\r\n  async evaluate(_context: PolicyContext): Promise<PolicyEvaluationResult> {\r\n    throw new Error('evaluate method requires policies to be passed in - use evaluatePolicies instead');\r\n  }\r\n\r\n  /**\r\n   * Evaluate multiple policies with deny-overrides strategy\r\n   */\r\n  async evaluatePolicies(\r\n    policies: Policy[],\r\n    context: PolicyContext,\r\n  ): Promise<PolicyEvaluationResult> {\r\n    const deniedRules: string[] = [];\r\n    const allowedRules: string[] = [];\r\n\r\n    // Sort policies by priority if available\r\n    const sortedPolicies = [...policies].filter((p) => p.enabled);\r\n\r\n    for (const policy of sortedPolicies) {\r\n      const result = await this.evaluatePolicy(policy, context);\r\n\r\n      if (result.effect === PolicyEffect.DENY) {\r\n        deniedRules.push(...result.matchedRules);\r\n      } else if (result.effect === PolicyEffect.ALLOW) {\r\n        allowedRules.push(...result.matchedRules);\r\n      }\r\n    }\r\n\r\n    // Deny-overrides: if any rule denies, access is denied\r\n    if (deniedRules.length > 0) {\r\n      return {\r\n        effect: PolicyEffect.DENY,\r\n        matchedRules: deniedRules,\r\n        reason: `Access denied by rules: ${deniedRules.join(', ')}`,\r\n      };\r\n    }\r\n\r\n    // If at least one rule allows, access is granted\r\n    if (allowedRules.length > 0) {\r\n      return {\r\n        effect: PolicyEffect.ALLOW,\r\n        matchedRules: allowedRules,\r\n        reason: `Access granted by rules: ${allowedRules.join(', ')}`,\r\n      };\r\n    }\r\n\r\n    // No rules matched - default deny\r\n    return {\r\n      effect: PolicyEffect.DENY,\r\n      matchedRules: [],\r\n      reason: 'No matching policy rules found (default deny)',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Evaluate a single policy\r\n   */\r\n  async evaluatePolicy(policy: Policy, context: PolicyContext): Promise<PolicyEvaluationResult> {\r\n    if (!policy.enabled) {\r\n      return {\r\n        effect: PolicyEffect.DENY,\r\n        matchedRules: [],\r\n        reason: 'Policy is disabled',\r\n      };\r\n    }\r\n\r\n    const matchedRules: string[] = [];\r\n    const deniedRules: string[] = [];\r\n    const allowedRules: string[] = [];\r\n\r\n    // Sort rules by priority (higher priority first)\r\n    const sortedRules = [...policy.rules].sort((a, b) => {\r\n      const priorityA = a.priority ?? 0;\r\n      const priorityB = b.priority ?? 0;\r\n      return priorityB - priorityA;\r\n    });\r\n\r\n    for (const rule of sortedRules) {\r\n      const matches = await this.evaluateRule(rule, context);\r\n\r\n      if (matches) {\r\n        matchedRules.push(rule.id);\r\n\r\n        if (rule.effect === PolicyEffect.DENY) {\r\n          deniedRules.push(rule.id);\r\n        } else {\r\n          allowedRules.push(rule.id);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Deny-overrides within policy\r\n    if (deniedRules.length > 0) {\r\n      return {\r\n        effect: PolicyEffect.DENY,\r\n        matchedRules: deniedRules,\r\n        reason: `Denied by rules: ${deniedRules.join(', ')}`,\r\n      };\r\n    }\r\n\r\n    if (allowedRules.length > 0) {\r\n      return {\r\n        effect: PolicyEffect.ALLOW,\r\n        matchedRules: allowedRules,\r\n        reason: `Allowed by rules: ${allowedRules.join(', ')}`,\r\n      };\r\n    }\r\n\r\n    // No rules matched in this policy\r\n    return {\r\n      effect: PolicyEffect.DENY,\r\n      matchedRules: [],\r\n      reason: 'No matching rules in policy',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Evaluate a single rule\r\n   */\r\n  async evaluateRule(rule: PolicyRule, context: PolicyContext): Promise<boolean> {\r\n    return this.evaluateConditions(rule.conditions, context);\r\n  }\r\n\r\n  /**\r\n   * Evaluate conditions (logical combination)\r\n   */\r\n  async evaluateConditions(\r\n    conditions: LogicalCondition,\r\n    context: PolicyContext,\r\n  ): Promise<boolean> {\r\n    switch (conditions.operator) {\r\n      case LogicalOperator.AND:\r\n        return this.evaluateAnd(conditions.conditions, context);\r\n\r\n      case LogicalOperator.OR:\r\n        return this.evaluateOr(conditions.conditions, context);\r\n\r\n      case LogicalOperator.NOT:\r\n        return this.evaluateNot(conditions.conditions, context);\r\n\r\n      default:\r\n        throw new Error(`Unsupported logical operator: ${conditions.operator}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluate AND conditions (all must be true)\r\n   */\r\n  private async evaluateAnd(\r\n    conditions: (Condition | LogicalCondition)[],\r\n    context: PolicyContext,\r\n  ): Promise<boolean> {\r\n    for (const condition of conditions) {\r\n      const result = await this.evaluateCondition(condition, context);\r\n      if (!result) {\r\n        return false;\r\n      }\r\n    }\r\n    return conditions.length > 0;\r\n  }\r\n\r\n  /**\r\n   * Evaluate OR conditions (at least one must be true)\r\n   */\r\n  private async evaluateOr(\r\n    conditions: (Condition | LogicalCondition)[],\r\n    context: PolicyContext,\r\n  ): Promise<boolean> {\r\n    for (const condition of conditions) {\r\n      const result = await this.evaluateCondition(condition, context);\r\n      if (result) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Evaluate NOT conditions (negation)\r\n   */\r\n  private async evaluateNot(\r\n    conditions: (Condition | LogicalCondition)[],\r\n    context: PolicyContext,\r\n  ): Promise<boolean> {\r\n    if (conditions.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    const firstCondition = conditions[0];\r\n    if (!firstCondition) {\r\n      return false;\r\n    }\r\n\r\n    const result = await this.evaluateCondition(firstCondition, context);\r\n    return !result;\r\n  }\r\n\r\n  /**\r\n   * Evaluate a single condition or logical condition\r\n   */\r\n  private async evaluateCondition(\r\n    condition: Condition | LogicalCondition,\r\n    context: PolicyContext,\r\n  ): Promise<boolean> {\r\n    // Check if it's a logical condition\r\n    if ('operator' in condition && 'conditions' in condition) {\r\n      return this.evaluateConditions(condition as LogicalCondition, context);\r\n    }\r\n\r\n    // Otherwise, it's a simple condition\r\n    return this.evaluateSimpleCondition(condition as Condition, context);\r\n  }\r\n\r\n  /**\r\n   * Evaluate a simple condition\r\n   */\r\n  private async evaluateSimpleCondition(\r\n    condition: Condition,\r\n    context: PolicyContext,\r\n  ): Promise<boolean> {\r\n    const actualValue = this.extractAttributeValue(condition.attribute, context);\r\n    const expectedValue = condition.value;\r\n\r\n    return this.compareValues(actualValue, condition.operator, expectedValue);\r\n  }\r\n\r\n  /**\r\n   * Extract attribute value from context\r\n   */\r\n  private extractAttributeValue(attribute: { source: string; key: string }, context: PolicyContext): any {\r\n    const sourceMap: Record<string, Record<string, any>> = {\r\n      user: context.user,\r\n      resource: context.resource,\r\n      environment: context.environment,\r\n      action: { value: context.action },\r\n    };\r\n\r\n    const source = sourceMap[attribute.source];\r\n    if (!source) {\r\n      return undefined;\r\n    }\r\n\r\n    // Support nested keys with dot notation (e.g., \"user.department\")\r\n    const keys = attribute.key.split('.');\r\n    let value: any = source;\r\n\r\n    for (const key of keys) {\r\n      if (value && typeof value === 'object') {\r\n        value = value[key];\r\n      } else {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Compare values using the specified operator\r\n   */\r\n  private compareValues(actual: any, operator: ComparisonOperator, expected: any): boolean {\r\n    switch (operator) {\r\n      case ComparisonOperator.EQUALS:\r\n        return actual === expected;\r\n\r\n      case ComparisonOperator.NOT_EQUALS:\r\n        return actual !== expected;\r\n\r\n      case ComparisonOperator.GREATER_THAN:\r\n        return actual > expected;\r\n\r\n      case ComparisonOperator.GREATER_THAN_OR_EQUAL:\r\n        return actual >= expected;\r\n\r\n      case ComparisonOperator.LESS_THAN:\r\n        return actual < expected;\r\n\r\n      case ComparisonOperator.LESS_THAN_OR_EQUAL:\r\n        return actual <= expected;\r\n\r\n      case ComparisonOperator.IN:\r\n        return Array.isArray(expected) && expected.includes(actual);\r\n\r\n      case ComparisonOperator.NOT_IN:\r\n        return Array.isArray(expected) && !expected.includes(actual);\r\n\r\n      case ComparisonOperator.CONTAINS:\r\n        if (typeof actual === 'string' && typeof expected === 'string') {\r\n          return actual.includes(expected);\r\n        }\r\n        if (Array.isArray(actual)) {\r\n          return actual.includes(expected);\r\n        }\r\n        return false;\r\n\r\n      case ComparisonOperator.MATCHES:\r\n        if (typeof actual === 'string' && typeof expected === 'string') {\r\n          try {\r\n            const regex = new RegExp(expected);\r\n            return regex.test(actual);\r\n          } catch {\r\n            return false;\r\n          }\r\n        }\r\n        return false;\r\n\r\n      default:\r\n        throw new Error(`Unsupported comparison operator: ${operator}`);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\auth\\policy-store.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\cache.service.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":10,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":10,"endColumn":12},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":14,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":14,"endColumn":12},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":19,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":19,"endColumn":14},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":25,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":25,"endColumn":12},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":29,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":29,"endColumn":15},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":33,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":33,"endColumn":15},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":37,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":37,"endColumn":13},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":41,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":41,"endColumn":16},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":46,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":46,"endColumn":13},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":50,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":50,"endColumn":13},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":55,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":55,"endColumn":5},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1300,1303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1300,1303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1776,1779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1776,1779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5754,5757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5754,5757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Redis from 'ioredis';\r\nimport { inject, singleton } from 'tsyringe';\r\n\r\nimport { LoggerService } from './logger.service';\r\n\r\n// Minimal in-memory mock implementing the Redis subset used in tests\r\nclass MockRedis {\r\n  private store = new Map<string, string>();\r\n\r\n  async get(key: string) {\r\n    return this.store.get(key) ?? null;\r\n  }\r\n\r\n  async set(key: string, value: string) {\r\n    this.store.set(key, value);\r\n    return 'OK';\r\n  }\r\n\r\n  async setex(key: string, _ttl: number, value: string) {\r\n    this.store.set(key, value);\r\n    // TTL ignored for mock\r\n    return 'OK';\r\n  }\r\n\r\n  async del(key: string) {\r\n    return this.store.delete(key) ? 1 : 0;\r\n  }\r\n\r\n  async exists(key: string) {\r\n    return this.store.has(key) ? 1 : 0;\r\n  }\r\n\r\n  async expire(_key: string, _ttl: number) {\r\n    return 1;\r\n  }\r\n\r\n  async mget(...keys: string[]) {\r\n    return keys.map((k) => this.store.get(k) ?? null);\r\n  }\r\n\r\n  async flushdb() {\r\n    this.store.clear();\r\n    return 'OK';\r\n  }\r\n\r\n  async ping() {\r\n    return 'PONG';\r\n  }\r\n\r\n  async quit() {\r\n    return 'OK';\r\n  }\r\n\r\n  // Event handlers compatibility stubs\r\n  on() {\r\n    // no-op for mock\r\n  }\r\n}\r\n\r\n/**\r\n * Redis caching service with DI\r\n * Implements cache-aside pattern\r\n */\r\n@singleton()\r\nexport class CacheService {\r\n  private client: any;\r\n\r\n  constructor(@inject(LoggerService) private logger: LoggerService) {\r\n    const disableExternal =\r\n      process.env['TEST_EXTERNAL_SERVICES'] === 'false' || process.env['REDIS_MOCK'] === 'true';\r\n\r\n    if (disableExternal) {\r\n      // Use in-memory mock to avoid long reconnect loops in tests\r\n      this.client = new MockRedis();\r\n      this.logger.info('Using MockRedis for tests');\r\n      return;\r\n    }\r\n\r\n    // Default Redis options\r\n    const defaultOptions: any = {\r\n      retryStrategy: (times: number) => {\r\n        const delay = Math.min(times * 50, 2000);\r\n        return delay;\r\n      },\r\n      maxRetriesPerRequest: 3,\r\n      enableOfflineQueue: true,\r\n      connectTimeout: 10000,\r\n    };\r\n\r\n    // Shorten retries / disable offline queue during test runs to fail fast\r\n    if (process.env['NODE_ENV'] === 'test') {\r\n      defaultOptions.maxRetriesPerRequest = 1;\r\n      defaultOptions.retryStrategy = () => null; // stop retrying\r\n      defaultOptions.enableOfflineQueue = false;\r\n      defaultOptions.connectTimeout = 1000;\r\n    }\r\n\r\n    this.client = new Redis(process.env['REDIS_URL'] || 'redis://localhost:6379', defaultOptions);\r\n\r\n    // Attach event handlers only if using real Redis\r\n    (this.client as Redis).on('connect', () => {\r\n      this.logger.info('Redis client connected');\r\n    });\r\n\r\n    (this.client as Redis).on('error', (err: Error) => {\r\n      this.logger.error('Redis client error', err);\r\n    });\r\n\r\n    (this.client as Redis).on('reconnecting', () => {\r\n      this.logger.warn('Redis client reconnecting');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get value from cache\r\n   */\r\n  async get<T>(key: string): Promise<T | null> {\r\n    try {\r\n      const value = await this.client.get(key);\r\n      if (!value) return null;\r\n      return JSON.parse(value) as T;\r\n    } catch (error) {\r\n      this.logger.error(`Cache get error for key: ${key}`, error as Error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set value in cache with optional TTL (seconds)\r\n   */\r\n  async set(key: string, value: unknown, ttl?: number): Promise<boolean> {\r\n    try {\r\n      const serialized = JSON.stringify(value);\r\n      if (ttl) {\r\n        await this.client.setex(key, ttl, serialized);\r\n      } else {\r\n        await this.client.set(key, serialized);\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error(`Cache set error for key: ${key}`, error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete value from cache\r\n   */\r\n  async delete(key: string): Promise<boolean> {\r\n    try {\r\n      await this.client.del(key);\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error(`Cache delete error for key: ${key}`, error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if key exists\r\n   */\r\n  async exists(key: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.client.exists(key);\r\n      return result === 1;\r\n    } catch (error) {\r\n      this.logger.error(`Cache exists error for key: ${key}`, error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set key expiration (seconds)\r\n   */\r\n  async expire(key: string, ttl: number): Promise<boolean> {\r\n    try {\r\n      await this.client.expire(key, ttl);\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error(`Cache expire error for key: ${key}`, error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get multiple keys\r\n   */\r\n  async mget<T>(keys: string[]): Promise<Array<T | null>> {\r\n    try {\r\n      const values = await this.client.mget(...keys);\r\n      return values.map((v: string | null) => (v ? (JSON.parse(v) as T) : null));\r\n    } catch (error) {\r\n      this.logger.error(`Cache mget error for keys: ${keys.join(', ')}`, error as Error);\r\n      return keys.map(() => null);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Flush all cache\r\n   */\r\n  async flush(): Promise<boolean> {\r\n    try {\r\n      await this.client.flushdb();\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error('Cache flush error', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check cache health\r\n   */\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const result = await this.client.ping();\r\n      return result === 'PONG';\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect from Redis\r\n   */\r\n  async disconnect(): Promise<void> {\r\n    await this.client.quit();\r\n  }\r\n\r\n  /**\r\n   * Get Redis client instance\r\n   */\r\n  getClient(): any {\r\n    return this.client;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\database.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\logger.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\notification-provider.factory.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":63,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":63,"endColumn":16,"suggestions":[{"fix":{"range":[2227,2278],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":64,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":64,"endColumn":16,"suggestions":[{"fix":{"range":[2284,2331],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":65,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":65,"endColumn":16,"suggestions":[{"fix":{"range":[2337,2399],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IEmailProvider, IPushNotificationProvider, ISmsProvider } from '@repo/types';\r\nimport { container } from 'tsyringe';\r\n\r\nimport { ConsoleEmailProvider } from './providers/console-email.provider';\r\nimport { ConsolePushProvider } from './providers/console-push.provider';\r\nimport { ConsoleSmsProvider } from './providers/console-sms.provider';\r\nimport { FcmPushProvider } from './providers/fcm-push.provider';\r\nimport { SendGridEmailProvider } from './providers/sendgrid-email.provider';\r\nimport { TwilioSmsProvider } from './providers/twilio-sms.provider';\r\n\r\n/**\r\n * Provider configuration based on environment\r\n */\r\nexport class NotificationProviderFactory {\r\n  /**\r\n   * Register notification providers based on environment configuration\r\n   */\r\n  static registerProviders(): void {\r\n    const emailProvider = process.env['EMAIL_PROVIDER'] || 'console';\r\n    const smsProvider = process.env['SMS_PROVIDER'] || 'console';\r\n    const pushProvider = process.env['PUSH_PROVIDER'] || 'console';\r\n\r\n    // Register email provider\r\n    switch (emailProvider.toLowerCase()) {\r\n      case 'sendgrid':\r\n        container.registerSingleton<IEmailProvider>('IEmailProvider', SendGridEmailProvider);\r\n        break;\r\n      case 'console':\r\n      default:\r\n        container.registerSingleton<IEmailProvider>('IEmailProvider', ConsoleEmailProvider);\r\n        break;\r\n    }\r\n\r\n    // Register SMS provider\r\n    switch (smsProvider.toLowerCase()) {\r\n      case 'twilio':\r\n        container.registerSingleton<ISmsProvider>('ISmsProvider', TwilioSmsProvider);\r\n        break;\r\n      case 'console':\r\n      default:\r\n        container.registerSingleton<ISmsProvider>('ISmsProvider', ConsoleSmsProvider);\r\n        break;\r\n    }\r\n\r\n    // Register push notification provider\r\n    switch (pushProvider.toLowerCase()) {\r\n      case 'fcm':\r\n      case 'firebase':\r\n        container.registerSingleton<IPushNotificationProvider>(\r\n          'IPushNotificationProvider',\r\n          FcmPushProvider\r\n        );\r\n        break;\r\n      case 'console':\r\n      default:\r\n        container.registerSingleton<IPushNotificationProvider>(\r\n          'IPushNotificationProvider',\r\n          ConsolePushProvider\r\n        );\r\n        break;\r\n    }\r\n\r\n    console.log(`­ƒôº Email provider: ${emailProvider}`);\r\n    console.log(`­ƒô▒ SMS provider: ${smsProvider}`);\r\n    console.log(`­ƒöö Push notification provider: ${pushProvider}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Helper function to register notification providers\r\n */\r\nexport function registerNotificationProviders(): void {\r\n  NotificationProviderFactory.registerProviders();\r\n}\r\n\r\n/**\r\n * Environment variables for provider selection:\r\n *\r\n * EMAIL_PROVIDER=console|sendgrid\r\n * SMS_PROVIDER=console|twilio\r\n * PUSH_PROVIDER=console|fcm|firebase\r\n *\r\n * Provider-specific credentials:\r\n *\r\n * SendGrid:\r\n * - SENDGRID_API_KEY\r\n * - SENDGRID_FROM_EMAIL\r\n *\r\n * Twilio:\r\n * - TWILIO_ACCOUNT_SID\r\n * - TWILIO_AUTH_TOKEN\r\n * - TWILIO_PHONE_NUMBER\r\n *\r\n * Firebase Cloud Messaging:\r\n * - FIREBASE_PROJECT_ID\r\n * - FIREBASE_SERVICE_ACCOUNT_KEY\r\n */\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\notification.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[632,635],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[632,635],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1347,1350],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1347,1350],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2052,2055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2052,2055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":97,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2886,2889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2886,2889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  EmailOptions,\r\n  IEmailProvider,\r\n  IPushNotificationProvider,\r\n  ISmsProvider,\r\n  PushNotificationOptions,\r\n  SmsOptions,\r\n} from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\nimport { LoggerService } from '../logger.service';\r\n\r\n/**\r\n * Main notification service that delegates to specific providers\r\n */\r\n@injectable()\r\nexport class NotificationService {\r\n  constructor(\r\n    private logger: LoggerService,\r\n    private emailProvider: IEmailProvider,\r\n    private smsProvider: ISmsProvider,\r\n    private pushProvider: IPushNotificationProvider\r\n  ) {}\r\n\r\n  async sendEmail(options: EmailOptions): Promise<any> {\r\n    try {\r\n      this.logger.info('Sending email', { to: options.to, subject: options.subject });\r\n      const result = await this.emailProvider.send(options);\r\n\r\n      if (result.success) {\r\n        this.logger.info('Email sent successfully', { messageId: result.messageId });\r\n      } else {\r\n        this.logger.error('Email send failed', new Error(result.error || 'Unknown error'));\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      this.logger.error('Email send error', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n        notificationId: Date.now().toString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  async sendSms(options: SmsOptions): Promise<any> {\r\n    try {\r\n      this.logger.info('Sending SMS', { to: options.to });\r\n      const result = await this.smsProvider.send(options);\r\n\r\n      if (result.success) {\r\n        this.logger.info('SMS sent successfully', { messageId: result.messageId });\r\n      } else {\r\n        this.logger.error('SMS send failed', new Error(result.error || 'Unknown error'));\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      this.logger.error('SMS send error', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n        notificationId: Date.now().toString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  async sendPushNotification(options: PushNotificationOptions): Promise<any> {\r\n    try {\r\n      this.logger.info('Sending push notification', {\r\n        userId: options.userId,\r\n        title: options.title,\r\n      });\r\n      const result = await this.pushProvider.send(options);\r\n\r\n      if (result.success) {\r\n        this.logger.info('Push notification sent successfully', { messageId: result.messageId });\r\n      } else {\r\n        this.logger.error(\r\n          'Push notification send failed',\r\n          new Error(result.error || 'Unknown error')\r\n        );\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      this.logger.error('Push notification send error', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n        notificationId: Date.now().toString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  async sendBulkEmail(emails: EmailOptions[]): Promise<any[]> {\r\n    this.logger.info('Sending bulk emails', { count: emails.length });\r\n\r\n    const results = await Promise.allSettled(emails.map((email) => this.sendEmail(email)));\r\n\r\n    return results.map((result) => {\r\n      if (result.status === 'fulfilled') {\r\n        return result.value;\r\n      } else {\r\n        return {\r\n          success: false,\r\n          error: result.reason?.message || 'Unknown error',\r\n          notificationId: Date.now().toString(),\r\n        };\r\n      }\r\n    });\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const [emailHealth, smsHealth, pushHealth] = await Promise.all([\r\n        this.emailProvider.healthCheck(),\r\n        this.smsProvider.healthCheck(),\r\n        this.pushProvider.healthCheck(),\r\n      ]);\r\n\r\n      return emailHealth && smsHealth && pushHealth;\r\n    } catch (error) {\r\n      this.logger.error('Notification service health check failed', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\console-email.provider.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":23,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":23,"endColumn":16,"suggestions":[{"fix":{"range":[705,744],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":24,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":24,"endColumn":16,"suggestions":[{"fix":{"range":[750,781],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":25,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":25,"endColumn":16,"suggestions":[{"fix":{"range":[787,847],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":26,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":26,"endColumn":16,"suggestions":[{"fix":{"range":[853,894],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":27,"column":21,"nodeType":"MemberExpression","messageId":"limited","endLine":27,"endColumn":32},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":28,"column":22,"nodeType":"MemberExpression","messageId":"limited","endLine":28,"endColumn":33},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":29,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":29,"endColumn":16,"suggestions":[{"fix":{"range":[1009,1067],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":30,"column":23,"nodeType":"MemberExpression","messageId":"limited","endLine":30,"endColumn":34},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":31,"column":30,"nodeType":"MemberExpression","messageId":"limited","endLine":31,"endColumn":41},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":32,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":32,"endColumn":16,"suggestions":[{"fix":{"range":[1249,1286],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EmailOptions, IEmailProvider, NotificationResult } from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\nimport { LoggerService } from '../../logger.service';\r\n\r\n/**\r\n * Console email provider for development\r\n * Logs emails to console instead of sending them\r\n */\r\n@injectable()\r\nexport class ConsoleEmailProvider implements IEmailProvider {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  async send(options: EmailOptions): Promise<NotificationResult> {\r\n    this.logger.info('­ƒôº Console Email Provider', {\r\n      to: options.to,\r\n      subject: options.subject,\r\n      from: options.from,\r\n      text: options.text,\r\n      html: options.html?.substring(0, 200),\r\n    });\r\n\r\n    console.log('\\n=== EMAIL MESSAGE ===');\r\n    console.log('To:', options.to);\r\n    console.log('From:', options.from || 'noreply@example.com');\r\n    console.log('Subject:', options.subject);\r\n    if (options.cc) console.log('CC:', options.cc);\r\n    if (options.bcc) console.log('BCC:', options.bcc);\r\n    console.log('\\nText:', options.text || 'No text content');\r\n    if (options.html) console.log('\\nHTML:', options.html.substring(0, 200) + '...');\r\n    if (options.attachments) console.log('\\nAttachments:', options.attachments.length);\r\n    console.log('===================\\n');\r\n\r\n    return {\r\n      success: true,\r\n      messageId: `console-email-${Date.now()}`,\r\n    };\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    return true;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\console-push.provider.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":25,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":25,"endColumn":16,"suggestions":[{"fix":{"range":[726,769],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":26,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":26,"endColumn":16,"suggestions":[{"fix":{"range":[775,815],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":27,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":27,"endColumn":16,"suggestions":[{"fix":{"range":[821,858],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":28,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":28,"endColumn":16,"suggestions":[{"fix":{"range":[864,899],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":29,"column":23,"nodeType":"MemberExpression","messageId":"limited","endLine":29,"endColumn":34},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":30,"column":24,"nodeType":"MemberExpression","messageId":"limited","endLine":30,"endColumn":35},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":31,"column":24,"nodeType":"MemberExpression","messageId":"limited","endLine":31,"endColumn":35},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":32,"column":23,"nodeType":"MemberExpression","messageId":"limited","endLine":32,"endColumn":34},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":33,"column":27,"nodeType":"MemberExpression","messageId":"limited","endLine":33,"endColumn":38},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":34,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":34,"endColumn":16,"suggestions":[{"fix":{"range":[1240,1282],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  IPushNotificationProvider,\r\n  NotificationResult,\r\n  PushNotificationOptions,\r\n} from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\nimport { LoggerService } from '../../logger.service';\r\n\r\n/**\r\n * Console push notification provider for development\r\n * Logs push notifications to console instead of sending them\r\n */\r\n@injectable()\r\nexport class ConsolePushProvider implements IPushNotificationProvider {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  async send(options: PushNotificationOptions): Promise<NotificationResult> {\r\n    this.logger.info('­ƒöö Console Push Notification Provider', {\r\n      userId: options.userId,\r\n      title: options.title,\r\n      body: options.body,\r\n    });\r\n\r\n    console.log('\\n=== PUSH NOTIFICATION ===');\r\n    console.log('User ID:', options.userId);\r\n    console.log('Title:', options.title);\r\n    console.log('Body:', options.body);\r\n    if (options.data) console.log('Data:', JSON.stringify(options.data, null, 2));\r\n    if (options.badge) console.log('Badge:', options.badge);\r\n    if (options.sound) console.log('Sound:', options.sound);\r\n    if (options.icon) console.log('Icon:', options.icon);\r\n    if (options.imageUrl) console.log('Image:', options.imageUrl);\r\n    console.log('========================\\n');\r\n\r\n    return {\r\n      success: true,\r\n      messageId: `console-push-${Date.now()}`,\r\n    };\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    return true;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\console-sms.provider.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":21,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":21,"endColumn":16,"suggestions":[{"fix":{"range":[618,655],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":22,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":22,"endColumn":16,"suggestions":[{"fix":{"range":[661,692],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":23,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":23,"endColumn":16,"suggestions":[{"fix":{"range":[698,750],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":24,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":24,"endColumn":16,"suggestions":[{"fix":{"range":[756,791],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":25,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":25,"endColumn":16,"suggestions":[{"fix":{"range":[797,833],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ISmsProvider, NotificationResult, SmsOptions } from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\nimport { LoggerService } from '../../logger.service';\r\n\r\n/**\r\n * Console SMS provider for development\r\n * Logs SMS messages to console instead of sending them\r\n */\r\n@injectable()\r\nexport class ConsoleSmsProvider implements ISmsProvider {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  async send(options: SmsOptions): Promise<NotificationResult> {\r\n    this.logger.info('­ƒô▒ Console SMS Provider', {\r\n      to: options.to,\r\n      from: options.from,\r\n      body: options.body,\r\n    });\r\n\r\n    console.log('\\n=== SMS MESSAGE ===');\r\n    console.log('To:', options.to);\r\n    console.log('From:', options.from || '+1234567890');\r\n    console.log('Body:', options.body);\r\n    console.log('==================\\n');\r\n\r\n    return {\r\n      success: true,\r\n      messageId: `console-sms-${Date.now()}`,\r\n    };\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    return true;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\fcm-push.provider.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":48,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":48,"endColumn":60,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[1632,1685],"text":"// @ts-expect-error - Used when firebase-admin is installed"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'message' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":49,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":49,"endColumn":20},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":103,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":103,"endColumn":56,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[3125,3178],"text":"// @ts-expect-error - Placeholder for future implementation"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used. Allowed unused args must match /^_/u.","line":104,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":104,"endColumn":39}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  IPushNotificationProvider,\r\n  NotificationResult,\r\n  PushNotificationOptions,\r\n} from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\nimport { LoggerService } from '../../logger.service';\r\n\r\n/**\r\n * Firebase Cloud Messaging (FCM) push notification provider\r\n * Requires FIREBASE_PROJECT_ID and FIREBASE_SERVICE_ACCOUNT_KEY environment variables\r\n */\r\n@injectable()\r\nexport class FcmPushProvider implements IPushNotificationProvider {\r\n  private projectId: string;\r\n  private serviceAccountKey: string;\r\n\r\n  constructor(private logger: LoggerService) {\r\n    this.projectId = process.env['FIREBASE_PROJECT_ID'] || '';\r\n    this.serviceAccountKey = process.env['FIREBASE_SERVICE_ACCOUNT_KEY'] || '';\r\n\r\n    if (!this.projectId || !this.serviceAccountKey) {\r\n      this.logger.warn('Firebase credentials not configured. Push notifications will fail.');\r\n    }\r\n  }\r\n\r\n  async send(options: PushNotificationOptions): Promise<NotificationResult> {\r\n    try {\r\n      if (!this.projectId) {\r\n        throw new Error('Firebase project ID not configured');\r\n      }\r\n\r\n      // Firebase Admin SDK implementation\r\n      // Note: Install firebase-admin package when ready to use\r\n      // const admin = require('firebase-admin');\r\n\r\n      // if (!admin.apps.length) {\r\n      //   admin.initializeApp({\r\n      //     credential: admin.credential.cert(JSON.parse(this.serviceAccountKey)),\r\n      //     projectId: this.projectId,\r\n      //   });\r\n      // }\r\n\r\n      // Get user's FCM token from database (would need to be stored during login)\r\n      // const fcmToken = await this.getUserFcmToken(options.userId);\r\n\r\n      // @ts-ignore - Used when firebase-admin is installed\r\n      const message = {\r\n        notification: {\r\n          title: options.title,\r\n          body: options.body,\r\n        },\r\n        data: options.data,\r\n        // token: fcmToken,\r\n        android: {\r\n          notification: {\r\n            icon: options.icon,\r\n            imageUrl: options.imageUrl,\r\n            sound: options.sound || 'default',\r\n          },\r\n        },\r\n        apns: {\r\n          payload: {\r\n            aps: {\r\n              badge: options.badge,\r\n              sound: options.sound || 'default',\r\n            },\r\n          },\r\n          fcmOptions: {\r\n            imageUrl: options.imageUrl,\r\n          },\r\n        },\r\n      };\r\n\r\n      // Uncomment when firebase-admin is installed:\r\n      // const response = await admin.messaging().send(message);\r\n\r\n      this.logger.info('FCM push notification sent', {\r\n        userId: options.userId,\r\n        title: options.title,\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        messageId: `fcm-${Date.now()}`, // Replace with response\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('FCM send failed', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n      };\r\n    }\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    // Check if credentials are configured\r\n    return !!(this.projectId && this.serviceAccountKey);\r\n  }\r\n\r\n  // Helper method to retrieve user's FCM token from database\r\n  // @ts-ignore - Placeholder for future implementation\r\n  private async getUserFcmToken(userId: string): Promise<string> {\r\n    // TODO: Implement database lookup for user's FCM token\r\n    // This would typically be stored when the user logs in from their device\r\n    throw new Error('FCM token lookup not implemented');\r\n  }\r\n}\r\n\r\n/**\r\n * Installation instructions:\r\n * pnpm add firebase-admin\r\n *\r\n * Environment variables:\r\n * FIREBASE_PROJECT_ID=your_project_id\r\n * FIREBASE_SERVICE_ACCOUNT_KEY='{\"type\":\"service_account\",\"project_id\":\"...\",\"private_key\":\"...\"}'\r\n *\r\n * Note: The service account key should be a JSON string of your Firebase service account credentials\r\n */\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\sendgrid-email.provider.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":35,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":35,"endColumn":60,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[1105,1158],"text":"// @ts-expect-error - Used when @sendgrid/mail is installed"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'message' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":36,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":20}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EmailOptions, IEmailProvider, NotificationResult } from '@repo/types';\r\nimport { injectable } from 'tsyringe';\r\n\r\nimport { LoggerService } from '../../logger.service';\r\n\r\n/**\r\n * SendGrid email provider\r\n * Requires SENDGRID_API_KEY environment variable\r\n */\r\n@injectable()\r\nexport class SendGridEmailProvider implements IEmailProvider {\r\n  private apiKey: string;\r\n  private fromEmail: string;\r\n\r\n  constructor(private logger: LoggerService) {\r\n    this.apiKey = process.env['SENDGRID_API_KEY'] || '';\r\n    this.fromEmail = process.env['SENDGRID_FROM_EMAIL'] || 'noreply@example.com';\r\n\r\n    if (!this.apiKey) {\r\n      this.logger.warn('SendGrid API key not configured. Email sending will fail.');\r\n    }\r\n  }\r\n\r\n  async send(options: EmailOptions): Promise<NotificationResult> {\r\n    try {\r\n      if (!this.apiKey) {\r\n        throw new Error('SendGrid API key not configured');\r\n      }\r\n\r\n      // SendGrid API implementation\r\n      // Note: Install @sendgrid/mail package when ready to use\r\n      // const sgMail = require('@sendgrid/mail');\r\n      // sgMail.setApiKey(this.apiKey);\r\n\r\n      // @ts-ignore - Used when @sendgrid/mail is installed\r\n      const message = {\r\n        to: options.to,\r\n        from: options.from || this.fromEmail,\r\n        subject: options.subject,\r\n        text: options.text,\r\n        html: options.html,\r\n        cc: options.cc,\r\n        bcc: options.bcc,\r\n        attachments: options.attachments?.map((att) => ({\r\n          filename: att.filename,\r\n          content: Buffer.isBuffer(att.content) ? att.content.toString('base64') : att.content,\r\n          type: att.contentType,\r\n          disposition: 'attachment',\r\n        })),\r\n      };\r\n\r\n      // Uncomment when @sendgrid/mail is installed:\r\n      // const [response] = await sgMail.send(message);\r\n\r\n      this.logger.info('SendGrid email sent', {\r\n        to: options.to,\r\n        subject: options.subject,\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        messageId: `sendgrid-${Date.now()}`, // Replace with response.messageId\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('SendGrid send failed', error as Error);\r\n      return {\r\n        success: false,\r\n        error: (error as Error).message,\r\n      };\r\n    }\r\n  }\r\n\r\n  async healthCheck(): Promise<boolean> {\r\n    // Check if API key is configured\r\n    return !!this.apiKey;\r\n  }\r\n}\r\n\r\n/**\r\n * Installation instructions:\r\n * pnpm add @sendgrid/mail\r\n *\r\n * Environment variables:\r\n * SENDGRID_API_KEY=your_sendgrid_api_key\r\n * SENDGRID_FROM_EMAIL=noreply@yourdomain.com\r\n */\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\notification\\providers\\twilio-sms.provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\secrets\\secrets-manager.service.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":26,"column":24,"nodeType":"MemberExpression","endLine":26,"endColumn":40},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":129,"column":21,"nodeType":"MemberExpression","endLine":129,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ISecretsManager, SecretInfo, SecretMetadata } from '@repo/types';\nimport { injectable } from 'tsyringe';\n\n/**\n * Environment-based secrets manager implementation\n * In production, this would integrate with HashiCorp Vault, AWS Secrets Manager, etc.\n */\n@injectable()\nexport class EnvironmentSecretsManager implements ISecretsManager {\n  private secrets: Map<string, { value: string; metadata: SecretMetadata }> = new Map();\n\n  constructor() {\n    this.initializeFromEnv();\n  }\n\n  /**\n   * Get secret value\n   */\n  async getSecret(key: string, _version?: string): Promise<string> {\n    // In production: fetch from Vault/AWS Secrets Manager/Azure Key Vault\n    // The version parameter would be used for versioned secret systems\n    const secret = this.secrets.get(key);\n\n    if (!secret) {\n      // Fall back to environment variable\n      const envValue = process.env[key];\n      if (!envValue) {\n        throw new Error(`Secret not found: ${key}`);\n      }\n      return envValue;\n    }\n\n    return secret.value;\n  }\n\n  /**\n   * Set secret value\n   */\n  async setSecret(key: string, value: string, metadata?: SecretMetadata): Promise<void> {\n    // In production: store in Vault/AWS Secrets Manager/Azure Key Vault\n    const existingSecret = this.secrets.get(key);\n    const secretMetadata: SecretMetadata = {\n      ...metadata,\n      createdAt: existingSecret?.metadata.createdAt || new Date(),\n      updatedAt: new Date(),\n      version: existingSecret ? this.incrementVersion(existingSecret.metadata.version) : '1',\n    };\n\n    this.secrets.set(key, {\n      value,\n      metadata: secretMetadata,\n    });\n  }\n\n  /**\n   * Delete secret\n   */\n  async deleteSecret(key: string): Promise<void> {\n    // In production: delete from Vault/AWS Secrets Manager/Azure Key Vault\n    this.secrets.delete(key);\n  }\n\n  /**\n   * List all secret keys\n   */\n  async listSecrets(prefix?: string): Promise<SecretInfo[]> {\n    // In production: list from Vault/AWS Secrets Manager/Azure Key Vault\n    const secrets: SecretInfo[] = [];\n\n    for (const [key, secret] of this.secrets.entries()) {\n      if (!prefix || key.startsWith(prefix)) {\n        secrets.push({\n          key,\n          metadata: secret.metadata,\n        });\n      }\n    }\n\n    return secrets;\n  }\n\n  /**\n   * Rotate secret\n   */\n  async rotateSecret(key: string, newValue: string): Promise<void> {\n    // In production:\n    // 1. Store new version\n    // 2. Update applications to use new version\n    // 3. Keep old version for grace period\n    // 4. Delete old version after grace period\n\n    const existingSecret = this.secrets.get(key);\n    if (!existingSecret) {\n      throw new Error(`Secret not found: ${key}`);\n    }\n\n    await this.setSecret(key, newValue, {\n      ...existingSecret.metadata,\n      rotationEnabled: true,\n    });\n  }\n\n  /**\n   * Get secret metadata\n   */\n  async getSecretMetadata(key: string): Promise<SecretMetadata> {\n    const secret = this.secrets.get(key);\n    if (!secret) {\n      throw new Error(`Secret not found: ${key}`);\n    }\n\n    return secret.metadata;\n  }\n\n  /**\n   * Initialize secrets from environment variables\n   */\n  private initializeFromEnv(): void {\n    // Load critical secrets from environment\n    const criticalSecrets = [\n      'JWT_ACCESS_SECRET',\n      'JWT_REFRESH_SECRET',\n      'ENCRYPTION_KEY',\n      'DATABASE_URL',\n      'REDIS_URL',\n    ];\n\n    for (const key of criticalSecrets) {\n      const value = process.env[key];\n      if (value) {\n        this.secrets.set(key, {\n          value,\n          metadata: {\n            description: `Loaded from environment: ${key}`,\n            createdAt: new Date(),\n            updatedAt: new Date(),\n            version: '1',\n          },\n        });\n      }\n    }\n  }\n\n  /**\n   * Increment version string\n   */\n  private incrementVersion(version?: string): string {\n    if (!version) return '1';\n    const num = parseInt(version, 10);\n    return (num + 1).toString();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\providers\\azure-blob-storage.provider.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":366,"column":12,"nodeType":"MemberExpression","endLine":366,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\n\nimport {\n  BlobSASPermissions,\n  BlobServiceClient,\n  ContainerClient,\n  StorageSharedKeyCredential,\n} from '@azure/storage-blob';\nimport {\n  DeleteOptions,\n  DownloadOptions,\n  FileMetadata,\n  IStorageProvider,\n  ListOptions,\n  UploadOptions,\n} from '@repo/types';\nimport { injectable } from 'tsyringe';\n\nimport { LoggerService } from '../../logger.service';\n\n/**\n * Azure Blob Storage provider\n * Stores files in Azure Blob Storage\n */\n@injectable()\nexport class AzureBlobStorageProvider implements IStorageProvider {\n  readonly providerName = 'azure-blob';\n  private readonly blobServiceClient: BlobServiceClient;\n  private readonly defaultContainer: string;\n\n  constructor(private logger: LoggerService) {\n    const accountName = process.env['AZURE_STORAGE_ACCOUNT_NAME'] || '';\n    const accountKey = process.env['AZURE_STORAGE_ACCOUNT_KEY'] || '';\n    this.defaultContainer = process.env['AZURE_STORAGE_CONTAINER'] || 'uploads';\n\n    if (!accountName || !accountKey) {\n      this.logger.warn('Azure Storage credentials not configured');\n      // Create a dummy client to avoid errors\n      this.blobServiceClient = {} as BlobServiceClient;\n    } else {\n      const sharedKeyCredential = new StorageSharedKeyCredential(accountName, accountKey);\n      this.blobServiceClient = new BlobServiceClient(\n        `https://${accountName}.blob.core.windows.net`,\n        sharedKeyCredential\n      );\n    }\n  }\n\n  async upload(\n    file: Buffer | NodeJS.ReadableStream,\n    options: UploadOptions\n  ): Promise<FileMetadata> {\n    try {\n      const filename = options.filename || this.generateFilename(options.contentType);\n      const folder = options.folder || 'default';\n      const blobName = `${folder}/${filename}`;\n      const containerName = options.bucket || this.defaultContainer;\n\n      // Validate file size if it's a Buffer\n      if (options.maxSize && Buffer.isBuffer(file) && file.length > options.maxSize) {\n        throw new Error(`File size ${file.length} exceeds maximum ${options.maxSize} bytes`);\n      }\n\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      await this.ensureContainerExists(containerClient);\n\n      const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n\n      if (Buffer.isBuffer(file)) {\n        await blockBlobClient.upload(file, file.length, {\n          blobHTTPHeaders: {\n            blobContentType: options.contentType || 'application/octet-stream',\n          },\n          metadata: options.metadata,\n        });\n      } else {\n        // @ts-expect-error - Stream type mismatch between web and node streams\n        await blockBlobClient.uploadStream(file, undefined, undefined, {\n          blobHTTPHeaders: {\n            blobContentType: options.contentType || 'application/octet-stream',\n          },\n          metadata: options.metadata,\n        });\n      }\n\n      // Get properties to get the actual size\n      const properties = await blockBlobClient.getProperties();\n\n      const url = blockBlobClient.url;\n\n      const metadata: FileMetadata = {\n        filename,\n        originalName: options.filename || filename,\n        mimeType: properties.contentType || 'application/octet-stream',\n        size: properties.contentLength || 0,\n        path: blobName,\n        url,\n        uploadedAt: properties.lastModified || new Date(),\n        bucket: containerName,\n        key: blobName,\n      };\n\n      this.logger.info('File uploaded to Azure Blob Storage', {\n        container: containerName,\n        blob: blobName,\n        size: metadata.size,\n      });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('Azure Blob upload failed', error as Error);\n      throw error;\n    }\n  }\n\n  async uploadMultiple(\n    files: Array<{ data: Buffer | NodeJS.ReadableStream; options: UploadOptions }>\n  ): Promise<FileMetadata[]> {\n    return Promise.all(files.map((f) => this.upload(f.data, f.options)));\n  }\n\n  async download(filePath: string, options?: DownloadOptions): Promise<Buffer> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      const downloadResponse = await blockBlobClient.download();\n\n      if (!downloadResponse.readableStreamBody) {\n        throw new Error('No stream body in Azure response');\n      }\n\n      const chunks: Buffer[] = [];\n      for await (const chunk of downloadResponse.readableStreamBody) {\n        chunks.push(Buffer.from(chunk));\n      }\n\n      const buffer = Buffer.concat(chunks);\n\n      this.logger.info('File downloaded from Azure Blob Storage', {\n        container: containerName,\n        blob: filePath,\n      });\n\n      return buffer;\n    } catch (_error) {\n      this.logger.error('Azure Blob download failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async getSignedUrl(filePath: string, options?: DownloadOptions): Promise<string> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      const expiresIn = options?.expiresIn || 3600; // 1 hour default\n      const expiryDate = new Date(Date.now() + expiresIn * 1000);\n\n      // Generate SAS token\n      const sasToken = await blockBlobClient.generateSasUrl({\n        permissions: BlobSASPermissions.parse('r'), // read only\n        expiresOn: expiryDate,\n      });\n\n      return sasToken;\n    } catch (error) {\n      this.logger.error('Azure Blob getSignedUrl failed', error as Error);\n      throw error;\n    }\n  }\n\n  async delete(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      await blockBlobClient.delete();\n\n      this.logger.info('File deleted from Azure Blob Storage', {\n        container: containerName,\n        blob: filePath,\n      });\n\n      return true;\n    } catch (_error) {\n      this.logger.error('Azure Blob delete failed', _error as Error);\n      return false;\n    }\n  }\n\n  async deleteMultiple(paths: string[], options?: DeleteOptions): Promise<boolean[]> {\n    return Promise.all(paths.map((p) => this.delete(p, options)));\n  }\n\n  async exists(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      return await blockBlobClient.exists();\n    } catch {\n      return false;\n    }\n  }\n\n  async list(options?: ListOptions): Promise<FileMetadata[]> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const folder = options?.folder || '';\n      const prefix = options?.prefix || folder;\n\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n\n      const files: FileMetadata[] = [];\n      let count = 0;\n      const maxResults = options?.maxResults || 1000;\n\n      for await (const blob of containerClient.listBlobsFlat({ prefix })) {\n        if (count >= maxResults) break;\n\n        files.push({\n          filename: blob.name.split('/').pop() || '',\n          originalName: blob.name.split('/').pop() || '',\n          mimeType: blob.properties.contentType || 'application/octet-stream',\n          size: blob.properties.contentLength || 0,\n          path: blob.name,\n          url: `${containerClient.url}/${blob.name}`,\n          uploadedAt: blob.properties.lastModified || new Date(),\n          bucket: containerName,\n          key: blob.name,\n        });\n\n        count++;\n      }\n\n      return files;\n    } catch (error) {\n      this.logger.error('Azure Blob list failed', error as Error);\n      return [];\n    }\n  }\n\n  async getMetadata(filePath: string, options?: DeleteOptions): Promise<FileMetadata> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n      const blockBlobClient = containerClient.getBlockBlobClient(filePath);\n\n      const properties = await blockBlobClient.getProperties();\n\n      return {\n        filename: filePath.split('/').pop() || '',\n        originalName: filePath.split('/').pop() || '',\n        mimeType: properties.contentType || 'application/octet-stream',\n        size: properties.contentLength || 0,\n        path: filePath,\n        url: blockBlobClient.url,\n        uploadedAt: properties.lastModified || new Date(),\n        bucket: containerName,\n        key: filePath,\n      };\n    } catch (error) {\n      this.logger.error('Azure Blob getMetadata failed', error as Error);\n      throw error;\n    }\n  }\n\n  async copy(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const containerName = options?.bucket || this.defaultContainer;\n      const containerClient = this.blobServiceClient.getContainerClient(containerName);\n\n      const sourceBlob = containerClient.getBlockBlobClient(sourcePath);\n      const destBlob = containerClient.getBlockBlobClient(destinationPath);\n\n      await destBlob.beginCopyFromURL(sourceBlob.url);\n\n      this.logger.info('File copied in Azure Blob Storage', {\n        container: containerName,\n        from: sourcePath,\n        to: destinationPath,\n      });\n\n      return this.getMetadata(destinationPath, options);\n    } catch (error) {\n      this.logger.error('Azure Blob copy failed', error as Error);\n      throw error;\n    }\n  }\n\n  async move(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const metadata = await this.copy(sourcePath, destinationPath, options);\n      await this.delete(sourcePath, options);\n\n      this.logger.info('File moved in Azure Blob Storage', {\n        from: sourcePath,\n        to: destinationPath,\n      });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('Azure Blob move failed', error as Error);\n      throw error;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      const containerClient = this.blobServiceClient.getContainerClient(this.defaultContainer);\n      await containerClient.exists();\n      return true;\n    } catch (error) {\n      this.logger.error('Azure Blob health check failed', error as Error);\n      return false;\n    }\n  }\n\n  // Helper methods\n\n  private async ensureContainerExists(containerClient: ContainerClient): Promise<void> {\n    try {\n      const exists = await containerClient.exists();\n      if (!exists) {\n        await containerClient.create();\n      }\n    } catch {\n      // Container might already exist\n    }\n  }\n\n  private generateFilename(mimeType?: string): string {\n    const timestamp = Date.now();\n    const random = crypto.randomBytes(8).toString('hex');\n    const ext = mimeType ? this.getExtensionFromMimeType(mimeType) : '';\n\n    return `${timestamp}-${random}${ext}`;\n  }\n\n  private getExtensionFromMimeType(mimeType: string): string {\n    const mimeMap: Record<string, string> = {\n      'image/jpeg': '.jpg',\n      'image/png': '.png',\n      'image/gif': '.gif',\n      'image/webp': '.webp',\n      'application/pdf': '.pdf',\n      'text/plain': '.txt',\n      'application/json': '.json',\n      'video/mp4': '.mp4',\n      'audio/mpeg': '.mp3',\n    };\n\n    return mimeMap[mimeType] || '';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\providers\\gcp-storage.provider.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":354,"column":12,"nodeType":"MemberExpression","endLine":354,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\n\nimport { Storage } from '@google-cloud/storage';\nimport {\n  DeleteOptions,\n  DownloadOptions,\n  FileMetadata,\n  IStorageProvider,\n  ListOptions,\n  UploadOptions,\n} from '@repo/types';\nimport { injectable } from 'tsyringe';\n\nimport { LoggerService } from '../../logger.service';\n\n/**\n * Google Cloud Storage provider\n * Stores files in Google Cloud Storage\n */\n@injectable()\nexport class GcpStorageProvider implements IStorageProvider {\n  readonly providerName = 'gcp-storage';\n  private readonly storage: Storage;\n  private readonly defaultBucket: string;\n\n  constructor(private logger: LoggerService) {\n    const projectId = process.env['GCP_PROJECT_ID'];\n    const keyFilename = process.env['GCP_KEY_FILE'];\n    this.defaultBucket = process.env['GCP_STORAGE_BUCKET'] || '';\n\n    if (!projectId || !keyFilename) {\n      this.logger.warn('GCP credentials not configured');\n      this.storage = {} as Storage;\n    } else {\n      this.storage = new Storage({\n        projectId,\n        keyFilename,\n      });\n    }\n\n    if (!this.defaultBucket) {\n      this.logger.warn('GCP_STORAGE_BUCKET not configured');\n    }\n  }\n\n  async upload(\n    file: Buffer | NodeJS.ReadableStream,\n    options: UploadOptions\n  ): Promise<FileMetadata> {\n    try {\n      const filename = options.filename || this.generateFilename(options.contentType);\n      const folder = options.folder || 'default';\n      const blobName = `${folder}/${filename}`;\n      const bucketName = options.bucket || this.defaultBucket;\n\n      // Validate file size if it's a Buffer\n      if (options.maxSize && Buffer.isBuffer(file) && file.length > options.maxSize) {\n        throw new Error(`File size ${file.length} exceeds maximum ${options.maxSize} bytes`);\n      }\n\n      const bucket = this.storage.bucket(bucketName);\n      const blob = bucket.file(blobName);\n\n      const uploadOptions = {\n        metadata: {\n          contentType: options.contentType || 'application/octet-stream',\n          metadata: options.metadata,\n        },\n        public: options.makePublic || false,\n      };\n\n      if (Buffer.isBuffer(file)) {\n        await blob.save(file, uploadOptions);\n      } else {\n        // Handle stream\n        await new Promise<void>((resolve, reject) => {\n          file\n            .pipe(\n              blob.createWriteStream({\n                metadata: uploadOptions.metadata,\n                public: uploadOptions.public,\n              })\n            )\n            .on('error', reject)\n            .on('finish', resolve);\n        });\n      }\n\n      // Get metadata\n      const [metadata] = await blob.getMetadata();\n\n      const url = options.makePublic\n        ? `https://storage.googleapis.com/${bucketName}/${blobName}`\n        : await this.getSignedUrl(blobName, { bucket: bucketName });\n\n      const fileMetadata: FileMetadata = {\n        filename,\n        originalName: options.filename || filename,\n        mimeType: metadata.contentType || 'application/octet-stream',\n        size: parseInt(String(metadata.size || '0'), 10),\n        path: blobName,\n        url,\n        uploadedAt: new Date(metadata.timeCreated || Date.now()),\n        bucket: bucketName,\n        key: blobName,\n      };\n\n      this.logger.info('File uploaded to GCP Storage', {\n        bucket: bucketName,\n        blob: blobName,\n        size: fileMetadata.size,\n      });\n\n      return fileMetadata;\n    } catch (_error) {\n      this.logger.error('GCP Storage upload failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async uploadMultiple(\n    files: Array<{ data: Buffer | NodeJS.ReadableStream; options: UploadOptions }>\n  ): Promise<FileMetadata[]> {\n    return Promise.all(files.map((f) => this.upload(f.data, f.options)));\n  }\n\n  async download(filePath: string, options?: DownloadOptions): Promise<Buffer> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      const [buffer] = await file.download();\n\n      this.logger.info('File downloaded from GCP Storage', {\n        bucket: bucketName,\n        file: filePath,\n      });\n\n      return buffer;\n    } catch (_error) {\n      this.logger.error('GCP Storage download failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async getSignedUrl(filePath: string, options?: DownloadOptions): Promise<string> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      const expiresIn = options?.expiresIn || 3600; // 1 hour default\n      const expiryDate = Date.now() + expiresIn * 1000;\n\n      const [url] = await file.getSignedUrl({\n        action: 'read',\n        expires: expiryDate,\n      });\n\n      return url;\n    } catch (_error) {\n      this.logger.error('GCP Storage getSignedUrl failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async delete(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      await file.delete();\n\n      this.logger.info('File deleted from GCP Storage', {\n        bucket: bucketName,\n        file: filePath,\n      });\n\n      return true;\n    } catch (_error) {\n      this.logger.error('GCP Storage delete failed', _error as Error);\n      return false;\n    }\n  }\n\n  async deleteMultiple(paths: string[], options?: DeleteOptions): Promise<boolean[]> {\n    return Promise.all(paths.map((p) => this.delete(p, options)));\n  }\n\n  async exists(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      const [exists] = await file.exists();\n      return exists;\n    } catch {\n      return false;\n    }\n  }\n\n  async list(options?: ListOptions): Promise<FileMetadata[]> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const folder = options?.folder || '';\n      const prefix = options?.prefix || folder;\n\n      const bucket = this.storage.bucket(bucketName);\n\n      const [files] = await bucket.getFiles({\n        prefix,\n        maxResults: options?.maxResults || 1000,\n      });\n\n      const fileMetadata: FileMetadata[] = await Promise.all(\n        files.map(async (file) => {\n          const [metadata] = await file.getMetadata();\n\n          return {\n            filename: file.name.split('/').pop() || '',\n            originalName: file.name.split('/').pop() || '',\n            mimeType: metadata.contentType || 'application/octet-stream',\n            size: parseInt(String(metadata.size || '0'), 10),\n            path: file.name,\n            url: `https://storage.googleapis.com/${bucketName}/${file.name}`,\n            uploadedAt: new Date(metadata.timeCreated || Date.now()),\n            bucket: bucketName,\n            key: file.name,\n          };\n        })\n      );\n\n      return fileMetadata;\n    } catch (_error) {\n      this.logger.error('GCP Storage list failed', _error as Error);\n      return [];\n    }\n  }\n\n  async getMetadata(filePath: string, options?: DeleteOptions): Promise<FileMetadata> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const file = bucket.file(filePath);\n\n      const [metadata] = await file.getMetadata();\n\n      return {\n        filename: filePath.split('/').pop() || '',\n        originalName: filePath.split('/').pop() || '',\n        mimeType: metadata.contentType || 'application/octet-stream',\n        size: parseInt(String(metadata.size || '0'), 10),\n        path: filePath,\n        url: `https://storage.googleapis.com/${bucketName}/${filePath}`,\n        uploadedAt: new Date(metadata.timeCreated || Date.now()),\n        bucket: bucketName,\n        key: filePath,\n      };\n    } catch (_error) {\n      this.logger.error('GCP Storage getMetadata failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async copy(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const sourceFile = bucket.file(sourcePath);\n      const destFile = bucket.file(destinationPath);\n\n      await sourceFile.copy(destFile);\n\n      this.logger.info('File copied in GCP Storage', {\n        bucket: bucketName,\n        from: sourcePath,\n        to: destinationPath,\n      });\n\n      return this.getMetadata(destinationPath, options);\n    } catch (_error) {\n      this.logger.error('GCP Storage copy failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async move(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const bucketName = options?.bucket || this.defaultBucket;\n      const bucket = this.storage.bucket(bucketName);\n      const sourceFile = bucket.file(sourcePath);\n      const destFile = bucket.file(destinationPath);\n\n      await sourceFile.move(destFile);\n\n      this.logger.info('File moved in GCP Storage', {\n        bucket: bucketName,\n        from: sourcePath,\n        to: destinationPath,\n      });\n\n      return this.getMetadata(destinationPath, options);\n    } catch (_error) {\n      this.logger.error('GCP Storage move failed', _error as Error);\n      throw _error;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      const bucket = this.storage.bucket(this.defaultBucket);\n      await bucket.exists();\n      return true;\n    } catch (_error) {\n      this.logger.error('GCP Storage health check failed', _error as Error);\n      return false;\n    }\n  }\n\n  // Helper methods\n\n  private generateFilename(mimeType?: string): string {\n    const timestamp = Date.now();\n    const random = crypto.randomBytes(8).toString('hex');\n    const ext = mimeType ? this.getExtensionFromMimeType(mimeType) : '';\n\n    return `${timestamp}-${random}${ext}`;\n  }\n\n  private getExtensionFromMimeType(mimeType: string): string {\n    const mimeMap: Record<string, string> = {\n      'image/jpeg': '.jpg',\n      'image/png': '.png',\n      'image/gif': '.gif',\n      'image/webp': '.webp',\n      'application/pdf': '.pdf',\n      'text/plain': '.txt',\n      'application/json': '.json',\n      'video/mp4': '.mp4',\n      'audio/mpeg': '.mp3',\n    };\n\n    return mimeMap[mimeType] || '';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\providers\\local-storage.provider.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"fs/promises\" with non literal argument at index 0","line":58,"column":15,"nodeType":"CallExpression","endLine":58,"endColumn":43},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found createWriteStream from package \"fs\" with non literal argument at index 0","line":61,"column":29,"nodeType":"CallExpression","endLine":61,"endColumn":56},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs/promises\" with non literal argument at index 0","line":70,"column":27,"nodeType":"CallExpression","endLine":70,"endColumn":44},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs/promises\" with non literal argument at index 0","line":100,"column":28,"nodeType":"CallExpression","endLine":100,"endColumn":49},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs/promises\" with non literal argument at index 0","line":120,"column":13,"nodeType":"CallExpression","endLine":120,"endColumn":32},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs/promises\" with non literal argument at index 0","line":172,"column":27,"nodeType":"CallExpression","endLine":172,"endColumn":44},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found rename from package \"fs/promises\" with non literal argument at index 0,1","line":224,"column":13,"nodeType":"CallExpression","endLine":224,"endColumn":52},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"fs/promises\" with non literal argument at index 0","line":242,"column":13,"nodeType":"CallExpression","endLine":242,"endColumn":41},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs/promises\" with non literal argument at index 0","line":243,"column":13,"nodeType":"CallExpression","endLine":243,"endColumn":32},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs/promises\" with non literal argument at index 0","line":256,"column":13,"nodeType":"CallExpression","endLine":256,"endColumn":51},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":286,"column":12,"nodeType":"MemberExpression","endLine":286,"endColumn":29},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readdir from package \"fs/promises\" with non literal argument at index 0","line":293,"column":29,"nodeType":"CallExpression","endLine":293,"endColumn":73},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs/promises\" with non literal argument at index 0","line":303,"column":31,"nodeType":"CallExpression","endLine":303,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\nimport { createWriteStream } from 'fs';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nimport {\n  DeleteOptions,\n  DownloadOptions,\n  FileMetadata,\n  IStorageProvider,\n  ListOptions,\n  UploadOptions,\n} from '@repo/types';\nimport { injectable } from 'tsyringe';\n\nimport { LoggerService } from '../../logger.service';\n\n/**\n * Local filesystem storage provider\n * Stores files in the local filesystem (development and testing)\n */\n@injectable()\nexport class LocalStorageProvider implements IStorageProvider {\n  readonly providerName = 'local';\n  private readonly basePath: string;\n  private readonly baseUrl: string;\n\n  constructor(private logger: LoggerService) {\n    this.basePath = process.env['STORAGE_PATH'] || path.join(process.cwd(), 'uploads');\n    this.baseUrl = process.env['STORAGE_BASE_URL'] || 'http://localhost:3001/uploads';\n\n    // Ensure base directory exists\n    this.ensureDirectory(this.basePath).catch((error) => {\n      this.logger.error('Failed to create storage directory', error);\n    });\n  }\n\n  async upload(\n    file: Buffer | NodeJS.ReadableStream,\n    options: UploadOptions\n  ): Promise<FileMetadata> {\n    try {\n      const filename = options.filename || this.generateFilename(options.contentType);\n      const folder = options.folder || 'default';\n      const filePath = path.join(folder, filename);\n      const fullPath = path.join(this.basePath, filePath);\n\n      // Ensure folder exists\n      await this.ensureDirectory(path.dirname(fullPath));\n\n      // Validate file size\n      if (options.maxSize && Buffer.isBuffer(file) && file.length > options.maxSize) {\n        throw new Error(`File size ${file.length} exceeds maximum ${options.maxSize} bytes`);\n      }\n\n      // Write file\n      if (Buffer.isBuffer(file)) {\n        await fs.writeFile(fullPath, file);\n      } else {\n        // Handle stream\n        const writeStream = createWriteStream(fullPath);\n        await new Promise<void>((resolve, reject) => {\n          file.pipe(writeStream);\n          file.on('error', reject);\n          writeStream.on('finish', () => resolve());\n          writeStream.on('error', reject);\n        });\n      }\n\n      const stats = await fs.stat(fullPath);\n\n      const metadata: FileMetadata = {\n        filename,\n        originalName: options.filename || filename,\n        mimeType: options.contentType || 'application/octet-stream',\n        size: stats.size,\n        path: filePath,\n        url: `${this.baseUrl}/${filePath}`,\n        uploadedAt: new Date(),\n      };\n\n      this.logger.info('File uploaded to local storage', { path: filePath, size: stats.size });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('Local storage upload failed', error as Error);\n      throw error;\n    }\n  }\n\n  async uploadMultiple(\n    files: Array<{ data: Buffer | NodeJS.ReadableStream; options: UploadOptions }>\n  ): Promise<FileMetadata[]> {\n    return Promise.all(files.map((f) => this.upload(f.data, f.options)));\n  }\n\n  async download(filePath: string, _options?: DownloadOptions): Promise<Buffer> {\n    try {\n      const fullPath = path.join(this.basePath, filePath);\n      const buffer = await fs.readFile(fullPath);\n\n      this.logger.info('File downloaded from local storage', { path: filePath });\n\n      return buffer;\n    } catch (error) {\n      this.logger.error('Local storage download failed', error as Error);\n      throw error;\n    }\n  }\n\n  async getSignedUrl(filePath: string, _options?: DownloadOptions): Promise<string> {\n    // For local storage, return the direct URL\n    // In production, this could return a signed URL with expiration\n    return `${this.baseUrl}/${filePath}`;\n  }\n\n  async delete(filePath: string, _options?: DeleteOptions): Promise<boolean> {\n    try {\n      const fullPath = path.join(this.basePath, filePath);\n      await fs.unlink(fullPath);\n\n      this.logger.info('File deleted from local storage', { path: filePath });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Local storage delete failed', error as Error);\n      return false;\n    }\n  }\n\n  async deleteMultiple(paths: string[], options?: DeleteOptions): Promise<boolean[]> {\n    return Promise.all(paths.map((p) => this.delete(p, options)));\n  }\n\n  async exists(filePath: string, _options?: DeleteOptions): Promise<boolean> {\n    try {\n      const fullPath = path.join(this.basePath, filePath);\n      await fs.access(fullPath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async list(options?: ListOptions): Promise<FileMetadata[]> {\n    try {\n      const folder = options?.folder || '';\n      const fullPath = path.join(this.basePath, folder);\n\n      const files = await this.listFilesRecursive(fullPath, folder);\n\n      // Apply prefix filter if provided\n      const filteredFiles = options?.prefix\n        ? files.filter((f) => f.path.startsWith(options.prefix!))\n        : files;\n\n      // Apply max results limit\n      const limitedFiles = options?.maxResults\n        ? filteredFiles.slice(0, options.maxResults)\n        : filteredFiles;\n\n      return limitedFiles;\n    } catch (error) {\n      this.logger.error('Local storage list failed', error as Error);\n      return [];\n    }\n  }\n\n  async getMetadata(filePath: string, _options?: DeleteOptions): Promise<FileMetadata> {\n    try {\n      const fullPath = path.join(this.basePath, filePath);\n      const stats = await fs.stat(fullPath);\n\n      return {\n        filename: path.basename(filePath),\n        originalName: path.basename(filePath),\n        mimeType: 'application/octet-stream', // Would need mime-type detection\n        size: stats.size,\n        path: filePath,\n        url: `${this.baseUrl}/${filePath}`,\n        uploadedAt: stats.birthtime,\n      };\n    } catch (error) {\n      this.logger.error('Local storage getMetadata failed', error as Error);\n      throw error;\n    }\n  }\n\n  async copy(\n    sourcePath: string,\n    destinationPath: string,\n    _options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const sourceFullPath = path.join(this.basePath, sourcePath);\n      const destFullPath = path.join(this.basePath, destinationPath);\n\n      // Ensure destination directory exists\n      await this.ensureDirectory(path.dirname(destFullPath));\n\n      await fs.copyFile(sourceFullPath, destFullPath);\n\n      this.logger.info('File copied in local storage', { from: sourcePath, to: destinationPath });\n\n      return this.getMetadata(destinationPath);\n    } catch (error) {\n      this.logger.error('Local storage copy failed', error as Error);\n      throw error;\n    }\n  }\n\n  async move(\n    sourcePath: string,\n    destinationPath: string,\n    _options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const sourceFullPath = path.join(this.basePath, sourcePath);\n      const destFullPath = path.join(this.basePath, destinationPath);\n\n      // Ensure destination directory exists\n      await this.ensureDirectory(path.dirname(destFullPath));\n\n      await fs.rename(sourceFullPath, destFullPath);\n\n      this.logger.info('File moved in local storage', { from: sourcePath, to: destinationPath });\n\n      return this.getMetadata(destinationPath);\n    } catch (error) {\n      this.logger.error('Local storage move failed', error as Error);\n      throw error;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      // Check if base directory is accessible\n      await fs.access(this.basePath);\n\n      // Try to write a test file\n      const testPath = path.join(this.basePath, '.healthcheck');\n      await fs.writeFile(testPath, 'ok');\n      await fs.unlink(testPath);\n\n      return true;\n    } catch (error) {\n      this.logger.error('Local storage health check failed', error as Error);\n      return false;\n    }\n  }\n\n  // Helper methods\n\n  private async ensureDirectory(dirPath: string): Promise<void> {\n    try {\n      await fs.mkdir(dirPath, { recursive: true });\n    } catch (error) {\n      // Directory might already exist\n      if ((error as NodeJS.ErrnoException).code !== 'EEXIST') {\n        throw error;\n      }\n    }\n  }\n\n  private generateFilename(mimeType?: string): string {\n    const timestamp = Date.now();\n    const random = crypto.randomBytes(8).toString('hex');\n    const ext = mimeType ? this.getExtensionFromMimeType(mimeType) : '';\n\n    return `${timestamp}-${random}${ext}`;\n  }\n\n  private getExtensionFromMimeType(mimeType: string): string {\n    const mimeMap: Record<string, string> = {\n      'image/jpeg': '.jpg',\n      'image/png': '.png',\n      'image/gif': '.gif',\n      'image/webp': '.webp',\n      'application/pdf': '.pdf',\n      'text/plain': '.txt',\n      'application/json': '.json',\n      'video/mp4': '.mp4',\n      'audio/mpeg': '.mp3',\n    };\n\n    return mimeMap[mimeType] || '';\n  }\n\n  private async listFilesRecursive(dirPath: string, relativePath: string): Promise<FileMetadata[]> {\n    const results: FileMetadata[] = [];\n\n    try {\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dirPath, entry.name);\n        const relPath = path.join(relativePath, entry.name);\n\n        if (entry.isDirectory()) {\n          const subFiles = await this.listFilesRecursive(fullPath, relPath);\n          results.push(...subFiles);\n        } else if (entry.isFile()) {\n          const stats = await fs.stat(fullPath);\n          results.push({\n            filename: entry.name,\n            originalName: entry.name,\n            mimeType: 'application/octet-stream',\n            size: stats.size,\n            path: relPath.replace(/\\\\/g, '/'),\n            url: `${this.baseUrl}/${relPath.replace(/\\\\/g, '/')}`,\n            uploadedAt: stats.birthtime,\n          });\n        }\n      }\n    } catch {\n      // Directory might not exist\n    }\n\n    return results;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\providers\\s3-storage.provider.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":378,"column":12,"nodeType":"MemberExpression","endLine":378,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\n\nimport {\n  CopyObjectCommand,\n  DeleteObjectCommand,\n  DeleteObjectsCommand,\n  GetObjectCommand,\n  HeadObjectCommand,\n  ListObjectsV2Command,\n  PutObjectCommand,\n  S3Client,\n} from '@aws-sdk/client-s3';\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner';\nimport {\n  DeleteOptions,\n  DownloadOptions,\n  FileMetadata,\n  IStorageProvider,\n  ListOptions,\n  UploadOptions,\n} from '@repo/types';\nimport { injectable } from 'tsyringe';\n\nimport { LoggerService } from '../../logger.service';\n\n/**\n * AWS S3 storage provider\n * Stores files in Amazon S3\n */\n@injectable()\nexport class S3StorageProvider implements IStorageProvider {\n  readonly providerName = 'aws-s3';\n  private readonly client: S3Client;\n  private readonly defaultBucket: string;\n\n  constructor(private logger: LoggerService) {\n    const region = process.env['AWS_REGION'] || 'us-east-1';\n    this.defaultBucket = process.env['AWS_S3_BUCKET'] || '';\n\n    this.client = new S3Client({\n      region,\n      credentials: {\n        accessKeyId: process.env['AWS_ACCESS_KEY_ID'] || '',\n        secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'] || '',\n      },\n    });\n\n    if (!this.defaultBucket) {\n      this.logger.warn('AWS_S3_BUCKET not configured, S3 storage may not work correctly');\n    }\n  }\n\n  async upload(\n    file: Buffer | NodeJS.ReadableStream,\n    options: UploadOptions\n  ): Promise<FileMetadata> {\n    try {\n      const filename = options.filename || this.generateFilename(options.contentType);\n      const folder = options.folder || 'default';\n      const key = `${folder}/${filename}`;\n      const bucket = options.bucket || this.defaultBucket;\n\n      // Validate file size if it's a Buffer\n      if (options.maxSize && Buffer.isBuffer(file) && file.length > options.maxSize) {\n        throw new Error(`File size ${file.length} exceeds maximum ${options.maxSize} bytes`);\n      }\n\n      const command = new PutObjectCommand({\n        Bucket: bucket,\n        Key: key,\n        // @ts-expect-error - ReadableStream type mismatch between web and node\n        Body: file,\n        ContentType: options.contentType || 'application/octet-stream',\n        Metadata: options.metadata,\n        ACL: options.makePublic ? 'public-read' : 'private',\n      });\n\n      await this.client.send(command);\n\n      // Get the uploaded file's metadata\n      const headCommand = new HeadObjectCommand({\n        Bucket: bucket,\n        Key: key,\n      });\n\n      const headResult = await this.client.send(headCommand);\n\n      const url = options.makePublic\n        ? `https://${bucket}.s3.amazonaws.com/${key}`\n        : await this.getSignedUrl(key, { bucket });\n\n      const metadata: FileMetadata = {\n        filename,\n        originalName: options.filename || filename,\n        mimeType: headResult.ContentType || 'application/octet-stream',\n        size: headResult.ContentLength || 0,\n        path: key,\n        url,\n        uploadedAt: headResult.LastModified || new Date(),\n        bucket,\n        key,\n      };\n\n      this.logger.info('File uploaded to S3', { bucket, key, size: metadata.size });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('S3 upload failed', error as Error);\n      throw error;\n    }\n  }\n\n  async uploadMultiple(\n    files: Array<{ data: Buffer | NodeJS.ReadableStream; options: UploadOptions }>\n  ): Promise<FileMetadata[]> {\n    return Promise.all(files.map((f) => this.upload(f.data, f.options)));\n  }\n\n  async download(filePath: string, options?: DownloadOptions): Promise<Buffer> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new GetObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      const response = await this.client.send(command);\n\n      if (!response.Body) {\n        throw new Error('No body in S3 response');\n      }\n\n      const chunks: Uint8Array[] = [];\n      for await (const chunk of response.Body as AsyncIterable<Uint8Array>) {\n        chunks.push(chunk);\n      }\n\n      const buffer = Buffer.concat(chunks);\n\n      this.logger.info('File downloaded from S3', { bucket, key: filePath });\n\n      return buffer;\n    } catch (error) {\n      this.logger.error('S3 download failed', error as Error);\n      throw error;\n    }\n  }\n\n  async getSignedUrl(filePath: string, options?: DownloadOptions): Promise<string> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n      const expiresIn = options?.expiresIn || 3600; // 1 hour default\n\n      const command = new GetObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      const url = await getSignedUrl(this.client, command, { expiresIn });\n\n      return url;\n    } catch (error) {\n      this.logger.error('S3 getSignedUrl failed', error as Error);\n      throw error;\n    }\n  }\n\n  async delete(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new DeleteObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      await this.client.send(command);\n\n      this.logger.info('File deleted from S3', { bucket, key: filePath });\n\n      return true;\n    } catch (error) {\n      this.logger.error('S3 delete failed', error as Error);\n      return false;\n    }\n  }\n\n  async deleteMultiple(paths: string[], options?: DeleteOptions): Promise<boolean[]> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      if (paths.length === 0) {\n        return [];\n      }\n\n      const command = new DeleteObjectsCommand({\n        Bucket: bucket,\n        Delete: {\n          Objects: paths.map((key) => ({ Key: key })),\n        },\n      });\n\n      const response = await this.client.send(command);\n\n      const deletedKeys = new Set(response.Deleted?.map((d) => d.Key) || []);\n      const results = paths.map((path) => deletedKeys.has(path));\n\n      this.logger.info('Multiple files deleted from S3', { bucket, count: deletedKeys.size });\n\n      return results;\n    } catch (error) {\n      this.logger.error('S3 deleteMultiple failed', error as Error);\n      return paths.map(() => false);\n    }\n  }\n\n  async exists(filePath: string, options?: DeleteOptions): Promise<boolean> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new HeadObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      await this.client.send(command);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async list(options?: ListOptions): Promise<FileMetadata[]> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n      const folder = options?.folder || '';\n      const prefix = options?.prefix || folder;\n\n      const command = new ListObjectsV2Command({\n        Bucket: bucket,\n        Prefix: prefix,\n        MaxKeys: options?.maxResults || 1000,\n      });\n\n      const response = await this.client.send(command);\n\n      const files: FileMetadata[] = (response.Contents || []).map((item) => ({\n        filename: item.Key?.split('/').pop() || '',\n        originalName: item.Key?.split('/').pop() || '',\n        mimeType: 'application/octet-stream',\n        size: item.Size || 0,\n        path: item.Key || '',\n        url: `https://${bucket}.s3.amazonaws.com/${item.Key}`,\n        uploadedAt: item.LastModified || new Date(),\n        bucket,\n        key: item.Key || '',\n      }));\n\n      return files;\n    } catch (error) {\n      this.logger.error('S3 list failed', error as Error);\n      return [];\n    }\n  }\n\n  async getMetadata(filePath: string, options?: DeleteOptions): Promise<FileMetadata> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new HeadObjectCommand({\n        Bucket: bucket,\n        Key: filePath,\n      });\n\n      const response = await this.client.send(command);\n\n      return {\n        filename: filePath.split('/').pop() || '',\n        originalName: filePath.split('/').pop() || '',\n        mimeType: response.ContentType || 'application/octet-stream',\n        size: response.ContentLength || 0,\n        path: filePath,\n        url: `https://${bucket}.s3.amazonaws.com/${filePath}`,\n        uploadedAt: response.LastModified || new Date(),\n        bucket,\n        key: filePath,\n      };\n    } catch (error) {\n      this.logger.error('S3 getMetadata failed', error as Error);\n      throw error;\n    }\n  }\n\n  async copy(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      const bucket = options?.bucket || this.defaultBucket;\n\n      const command = new CopyObjectCommand({\n        Bucket: bucket,\n        CopySource: `${bucket}/${sourcePath}`,\n        Key: destinationPath,\n      });\n\n      await this.client.send(command);\n\n      this.logger.info('File copied in S3', { bucket, from: sourcePath, to: destinationPath });\n\n      return this.getMetadata(destinationPath, options);\n    } catch (error) {\n      this.logger.error('S3 copy failed', error as Error);\n      throw error;\n    }\n  }\n\n  async move(\n    sourcePath: string,\n    destinationPath: string,\n    options?: DeleteOptions\n  ): Promise<FileMetadata> {\n    try {\n      // Copy then delete\n      const metadata = await this.copy(sourcePath, destinationPath, options);\n      await this.delete(sourcePath, options);\n\n      this.logger.info('File moved in S3', { from: sourcePath, to: destinationPath });\n\n      return metadata;\n    } catch (error) {\n      this.logger.error('S3 move failed', error as Error);\n      throw error;\n    }\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      // Try to list objects with max 1 result\n      const command = new ListObjectsV2Command({\n        Bucket: this.defaultBucket,\n        MaxKeys: 1,\n      });\n\n      await this.client.send(command);\n      return true;\n    } catch (error) {\n      this.logger.error('S3 health check failed', error as Error);\n      return false;\n    }\n  }\n\n  // Helper methods\n\n  private generateFilename(mimeType?: string): string {\n    const timestamp = Date.now();\n    const random = crypto.randomBytes(8).toString('hex');\n    const ext = mimeType ? this.getExtensionFromMimeType(mimeType) : '';\n\n    return `${timestamp}-${random}${ext}`;\n  }\n\n  private getExtensionFromMimeType(mimeType: string): string {\n    const mimeMap: Record<string, string> = {\n      'image/jpeg': '.jpg',\n      'image/png': '.png',\n      'image/gif': '.gif',\n      'image/webp': '.webp',\n      'application/pdf': '.pdf',\n      'text/plain': '.txt',\n      'application/json': '.json',\n      'video/mp4': '.mp4',\n      'audio/mpeg': '.mp3',\n    };\n\n    return mimeMap[mimeType] || '';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\storage-provider.factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\storage\\storage.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\user\\user.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\services\\webhook\\webhook.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\abac-scenarios.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\abac.integration.test.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":16,"column":70,"nodeType":"MemberExpression","endLine":16,"endColumn":82},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":20,"column":61,"nodeType":"MemberExpression","endLine":20,"endColumn":73}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, expect, it } from 'vitest';\n\ndescribe('ABAC (Attribute-Based Access Control) smoke test', () => {\n  it('grants or denies access based on matching attributes', () => {\n    const userAttrs = {\n      department: 'engineering',\n      level: 'senior',\n      clearance: 'confidential',\n    } as Record<string, string>;\n\n    const requirements = {\n      department: 'engineering',\n      clearance: 'confidential',\n    } as Record<string, string>;\n\n    const hasAccess = Object.entries(requirements).every(([k, v]) => userAttrs[k] === v);\n    expect(hasAccess).toBe(true);\n\n    const badReq = { department: 'sales' };\n    const denied = Object.entries(badReq).every(([k, v]) => userAttrs[k] === v);\n    expect(denied).toBe(false);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\audit_log.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\authorization.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\cache_rate_limit.integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[749,752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[749,752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[759,762],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[759,762],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[770,773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[770,773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\r\nimport request from 'supertest';\r\nimport { describe, it } from 'vitest';\r\n\r\nimport { CacheService } from '../../services/cache.service';\r\nimport { LoggerService } from '../../services/logger.service';\r\n\r\ndescribe('Cache-backed Rate Limiter Integration', () => {\r\n  it('uses CacheService to enforce rate limits', async () => {\r\n    // Ensure tests use in-memory mock Redis to avoid external dependencies\r\n    process.env.REDIS_MOCK = 'true';\r\n    const mockLogger = {\r\n      info: () => {},\r\n      error: () => {},\r\n      warn: () => {},\r\n    } as unknown as LoggerService;\r\n    const cache = new CacheService(mockLogger);\r\n    await cache.flush();\r\n\r\n    const app = express();\r\n\r\n    const rateLimiter = async (req: any, res: any, next: any) => {\r\n      const key = `rl:${req.ip || 'test-ip'}`;\r\n      const existing = (await cache.get<number>(key)) || 0;\r\n      const count = existing + 1;\r\n      await cache.set(key, count, 60);\r\n      if (count > 3) {\r\n        res.status(429).json({ error: 'Too Many Requests' });\r\n        return;\r\n      }\r\n      next();\r\n    };\r\n\r\n    app.get('/api/limited', rateLimiter, (_req, res) => res.json({ ok: true }));\r\n\r\n    const agent = request(app);\r\n    await agent.get('/api/limited').expect(200);\r\n    // inspect cache after first request\r\n    await agent.get('/api/limited').expect(200);\r\n    await agent.get('/api/limited').expect(200);\r\n    // inspect cache before final check\r\n    await agent.get('/api/limited').expect(429);\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\cors.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\database.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\di.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\encryption.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\input_validation.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\logout.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\password_strength.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\rate_limit.integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[307,310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[307,310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[317,320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[317,320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[328,331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[328,331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":11,"column":19,"nodeType":"MemberExpression","endLine":11,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":17,"column":5,"nodeType":"MemberExpression","endLine":17,"endColumn":14}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport request from 'supertest';\nimport { describe, expect, it } from 'vitest';\n\n// Simple in-memory rate limiter for tests\nfunction simpleRateLimiter(maxRequests: number, windowMs: number) {\n  const hits: Record<string, { count: number; reset: number }> = {};\n  return (req: any, res: any, next: any) => {\n    const key = req.ip || 'test-ip';\n    const now = Date.now();\n    const entry = hits[key] || { count: 0, reset: now + windowMs };\n    if (now > entry.reset) {\n      entry.count = 0;\n      entry.reset = now + windowMs;\n    }\n    entry.count += 1;\n    hits[key] = entry;\n\n    res.setHeader('X-RateLimit-Limit', String(maxRequests));\n    res.setHeader('X-RateLimit-Remaining', String(Math.max(0, maxRequests - entry.count)));\n\n    if (entry.count > maxRequests) {\n      res.status(429).json({ error: 'Too Many Requests' });\n      return;\n    }\n\n    next();\n  };\n}\n\ndescribe('Rate Limiting Integration', () => {\n  it('allows up to 5 requests then returns 429', async () => {\n    const app = express();\n    app.use(simpleRateLimiter(5, 60 * 1000));\n    app.get('/api/auth/login', (_req, res) => res.json({ ok: true }));\n\n    // Make 5 requests - should succeed\n    for (let i = 0; i < 5; i += 1) {\n      const res = await request(app).get('/api/auth/login').expect(200);\n      expect(res.body.ok).toBe(true);\n    }\n\n    // 6th request should be rate-limited\n    await request(app).get('/api/auth/login').expect(429);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\redis.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\secrets.integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[767,770],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[767,770],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, expect, it } from 'vitest';\r\n\r\nimport { EnvironmentSecretsManager } from '../../services/secrets/secrets-manager.service';\r\n\r\ndescribe('Secrets Manager Integration', () => {\r\n  it('loads secrets from environment variables', async () => {\r\n    process.env['JWT_ACCESS_SECRET'] = 'test-access-secret-xyz';\r\n    const mgr = new EnvironmentSecretsManager();\r\n\r\n    const value = await mgr.getSecret('JWT_ACCESS_SECRET');\r\n    expect(value).toBe('test-access-secret-xyz');\r\n\r\n    // Unknown secret should fall back to env and throw if missing\r\n    delete process.env['SOME_RANDOM_SECRET'];\r\n    try {\r\n       \r\n      await mgr.getSecret('SOME_RANDOM_SECRET');\r\n      throw new Error('Expected getSecret to throw for missing secret');\r\n    } catch (err: any) {\r\n      expect(err.message).toMatch(/Secret not found/);\r\n    }\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\security.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\session.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\integration\\user.routes.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\services\\encryption.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\services\\jwt.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\services\\logger.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\services\\policy-engine.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\tests\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\utils\\hateoas.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[211,214],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[211,214],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[293,296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[293,296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[348,351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[348,351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[639,642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[639,642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":36,"column":5,"nodeType":"MemberExpression","endLine":36,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[843,846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[843,846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":112,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2362,2365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2362,2365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":113,"column":5,"nodeType":"MemberExpression","endLine":113,"endColumn":19},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":186,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":186,"endColumn":36},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":199,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":199,"endColumn":38}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request } from 'express';\n\nexport interface HateoasLink {\n  href: string;\n  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  rel: string;\n  type?: string;\n}\n\nexport interface HateoasResponse<T = any> {\n  data: T;\n  _links: Record<string, HateoasLink>;\n  _meta?: Record<string, any>;\n}\n\nexport interface PaginatedHateoasResponse<T = any> extends HateoasResponse<T[]> {\n  _meta: {\n    total: number;\n    page: number;\n    pageSize: number;\n    totalPages: number;\n  };\n}\n\n/**\n * Helper to build HATEOAS links\n */\nexport class HateoasBuilder {\n  private links: Record<string, HateoasLink> = {};\n  private meta: Record<string, any> = {};\n\n  /**\n   * Add a link to the response\n   */\n  addLink(rel: string, href: string, method?: string, type?: string): this {\n    this.links[rel] = {\n      href,\n      rel,\n      method: method as any,\n      type,\n    };\n    return this;\n  }\n\n  /**\n   * Add self link\n   */\n  self(href: string): this {\n    return this.addLink('self', href, 'GET', 'application/json');\n  }\n\n  /**\n   * Add collection link\n   */\n  collection(href: string): this {\n    return this.addLink('collection', href, 'GET', 'application/json');\n  }\n\n  /**\n   * Add create link\n   */\n  create(href: string): this {\n    return this.addLink('create', href, 'POST', 'application/json');\n  }\n\n  /**\n   * Add update link\n   */\n  update(href: string): this {\n    return this.addLink('update', href, 'PUT', 'application/json');\n  }\n\n  /**\n   * Add delete link\n   */\n  delete(href: string): this {\n    return this.addLink('delete', href, 'DELETE');\n  }\n\n  /**\n   * Add pagination links\n   */\n  pagination(baseUrl: string, page: number, pageSize: number, total: number): this {\n    const totalPages = Math.ceil(total / pageSize);\n\n    // First page\n    if (page > 1) {\n      this.addLink('first', `${baseUrl}?page=1&pageSize=${pageSize}`, 'GET');\n    }\n\n    // Previous page\n    if (page > 1) {\n      this.addLink('prev', `${baseUrl}?page=${page - 1}&pageSize=${pageSize}`, 'GET');\n    }\n\n    // Next page\n    if (page < totalPages) {\n      this.addLink('next', `${baseUrl}?page=${page + 1}&pageSize=${pageSize}`, 'GET');\n    }\n\n    // Last page\n    if (page < totalPages) {\n      this.addLink('last', `${baseUrl}?page=${totalPages}&pageSize=${pageSize}`, 'GET');\n    }\n\n    return this;\n  }\n\n  /**\n   * Add metadata\n   */\n  addMeta(key: string, value: any): this {\n    this.meta[key] = value;\n    return this;\n  }\n\n  /**\n   * Build the HATEOAS response\n   */\n  build<T>(data: T): HateoasResponse<T> {\n    const response: HateoasResponse<T> = {\n      data,\n      _links: this.links,\n    };\n\n    if (Object.keys(this.meta).length > 0) {\n      response._meta = this.meta;\n    }\n\n    return response;\n  }\n\n  /**\n   * Build paginated HATEOAS response\n   */\n  buildPaginated<T>(\n    data: T[],\n    total: number,\n    page: number,\n    pageSize: number\n  ): PaginatedHateoasResponse<T> {\n    const totalPages = Math.ceil(total / pageSize);\n\n    return {\n      data,\n      _links: this.links,\n      _meta: {\n        total,\n        page,\n        pageSize,\n        totalPages,\n        ...this.meta,\n      },\n    };\n  }\n}\n\n/**\n * Create a HATEOAS response builder\n */\nexport function hateoas(): HateoasBuilder {\n  return new HateoasBuilder();\n}\n\n/**\n * Get base URL from request\n */\nexport function getBaseUrl(req: Request): string {\n  const protocol = req.protocol;\n  const host = req.get('host');\n  return `${protocol}://${host}`;\n}\n\n/**\n * Build full URL from request path\n */\nexport function buildUrl(req: Request, path?: string): string {\n  const baseUrl = getBaseUrl(req);\n  const resourcePath = path || req.originalUrl.split('?')[0];\n  return `${baseUrl}${resourcePath}`;\n}\n\n/**\n * Helper to create standard resource links\n */\nexport function createResourceLinks(req: Request, resourceId: string, basePath: string) {\n  const baseUrl = getBaseUrl(req);\n\n  return hateoas()\n    .self(`${baseUrl}${basePath}/${resourceId}`)\n    .collection(`${baseUrl}${basePath}`)\n    .update(`${baseUrl}${basePath}/${resourceId}`)\n    .delete(`${baseUrl}${basePath}/${resourceId}`);\n}\n\n/**\n * Helper to create collection links with pagination\n */\nexport function createCollectionLinks(\n  req: Request,\n  basePath: string,\n  page: number,\n  pageSize: number,\n  total: number\n) {\n  const baseUrl = getBaseUrl(req);\n\n  return hateoas()\n    .self(buildUrl(req))\n    .create(`${baseUrl}${basePath}`)\n    .pagination(`${baseUrl}${basePath}`, page, pageSize, total);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Development\\next-node-app-base\\apps\\backend\\src\\utils\\query-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2054,2057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2054,2057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2232,2235],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2232,2235],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":115,"column":26,"nodeType":"MemberExpression","endLine":115,"endColumn":45},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":123,"column":20,"nodeType":"MemberExpression","endLine":123,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":151,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3145,3148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3145,3148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":152,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3166,3169],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3166,3169],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":159,"column":9,"nodeType":"MemberExpression","endLine":159,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":162,"column":9,"nodeType":"MemberExpression","endLine":162,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":165,"column":9,"nodeType":"MemberExpression","endLine":165,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":168,"column":9,"nodeType":"MemberExpression","endLine":168,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":171,"column":9,"nodeType":"MemberExpression","endLine":171,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":174,"column":9,"nodeType":"MemberExpression","endLine":174,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":177,"column":9,"nodeType":"MemberExpression","endLine":177,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":180,"column":9,"nodeType":"MemberExpression","endLine":180,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":183,"column":9,"nodeType":"MemberExpression","endLine":183,"endColumn":21},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":186,"column":9,"nodeType":"MemberExpression","endLine":186,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":223,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4807,4810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4807,4810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request } from 'express';\nimport { z } from 'zod';\n\n/**\n * Standard pagination query parameters\n */\nexport const paginationSchema = z.object({\n  page: z\n    .string()\n    .optional()\n    .default('1')\n    .transform((val: string) => parseInt(val, 10))\n    .refine((val: number) => val > 0, { message: 'Page must be greater than 0' }),\n  pageSize: z\n    .string()\n    .optional()\n    .default('10')\n    .transform((val: string) => parseInt(val, 10))\n    .refine((val: number) => val > 0 && val <= 100, {\n      message: 'Page size must be between 1 and 100',\n    }),\n  sort: z.string().optional(),\n  order: z.enum(['asc', 'desc']).optional().default('asc'),\n});\n\nexport type PaginationParams = z.infer<typeof paginationSchema>;\n\n/**\n * Extract and validate pagination parameters from request\n */\nexport function getPaginationParams(req: Request): PaginationParams {\n  const result = paginationSchema.safeParse(req.query);\n\n  if (!result.success) {\n    throw new Error(`Invalid pagination parameters: ${result.error.message}`);\n  }\n\n  return result.data;\n}\n\n/**\n * Pagination metadata\n */\nexport interface PaginationMeta {\n  total: number;\n  page: number;\n  pageSize: number;\n  totalPages: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n\n/**\n * Calculate pagination metadata\n */\nexport function calculatePaginationMeta(\n  total: number,\n  page: number,\n  pageSize: number\n): PaginationMeta {\n  const totalPages = Math.ceil(total / pageSize);\n\n  return {\n    total,\n    page,\n    pageSize,\n    totalPages,\n    hasNextPage: page < totalPages,\n    hasPreviousPage: page > 1,\n  };\n}\n\n/**\n * Calculate skip and take for database queries\n */\nexport function getSkipTake(page: number, pageSize: number): { skip: number; take: number } {\n  return {\n    skip: (page - 1) * pageSize,\n    take: pageSize,\n  };\n}\n\n/**\n * Filtering helper\n */\nexport interface FilterParams {\n  field: string;\n  operator:\n    | 'eq'\n    | 'ne'\n    | 'gt'\n    | 'gte'\n    | 'lt'\n    | 'lte'\n    | 'in'\n    | 'contains'\n    | 'startsWith'\n    | 'endsWith';\n  value: any;\n}\n\n/**\n * Parse filter parameters from query string\n * Format: filter[field][operator]=value\n * Example: filter[name][contains]=john\n */\nexport function parseFilters(query: any): FilterParams[] {\n  const filters: FilterParams[] = [];\n\n  if (!query.filter || typeof query.filter !== 'object') {\n    return filters;\n  }\n\n  Object.keys(query.filter).forEach((field) => {\n    const fieldFilters = query.filter[field];\n\n    if (typeof fieldFilters === 'object') {\n      Object.keys(fieldFilters).forEach((operator) => {\n        if (isValidOperator(operator)) {\n          filters.push({\n            field,\n            operator: operator as FilterParams['operator'],\n            value: fieldFilters[operator],\n          });\n        }\n      });\n    }\n  });\n\n  return filters;\n}\n\nfunction isValidOperator(op: string): boolean {\n  return [\n    'eq',\n    'ne',\n    'gt',\n    'gte',\n    'lt',\n    'lte',\n    'in',\n    'contains',\n    'startsWith',\n    'endsWith',\n  ].includes(op);\n}\n\n/**\n * Convert filters to Prisma where clause\n */\nexport function filtersToPrismaWhere(filters: FilterParams[]): any {\n  const where: any = {};\n\n  filters.forEach((filter) => {\n    const { field, operator, value } = filter;\n\n    switch (operator) {\n      case 'eq':\n        where[field] = value;\n        break;\n      case 'ne':\n        where[field] = { not: value };\n        break;\n      case 'gt':\n        where[field] = { gt: value };\n        break;\n      case 'gte':\n        where[field] = { gte: value };\n        break;\n      case 'lt':\n        where[field] = { lt: value };\n        break;\n      case 'lte':\n        where[field] = { lte: value };\n        break;\n      case 'in':\n        where[field] = { in: Array.isArray(value) ? value : [value] };\n        break;\n      case 'contains':\n        where[field] = { contains: value, mode: 'insensitive' };\n        break;\n      case 'startsWith':\n        where[field] = { startsWith: value, mode: 'insensitive' };\n        break;\n      case 'endsWith':\n        where[field] = { endsWith: value, mode: 'insensitive' };\n        break;\n    }\n  });\n\n  return where;\n}\n\n/**\n * Sorting helper\n */\nexport interface SortParams {\n  field: string;\n  order: 'asc' | 'desc';\n}\n\n/**\n * Parse sort parameters from query string\n * Format: sort=field1:asc,field2:desc\n */\nexport function parseSorting(sortQuery?: string): SortParams[] {\n  if (!sortQuery) {\n    return [];\n  }\n\n  return sortQuery.split(',').map((sortItem) => {\n    const [field, order = 'asc'] = sortItem.split(':');\n    return {\n      field: field?.trim() || '',\n      order: (order.toLowerCase() === 'desc' ? 'desc' : 'asc') as 'asc' | 'desc',\n    };\n  });\n}\n\n/**\n * Convert sort params to Prisma orderBy clause\n */\nexport function sortToPrismaOrderBy(sorts: SortParams[]): any {\n  if (sorts.length === 0) {\n    return undefined;\n  }\n\n  if (sorts.length === 1 && sorts[0]) {\n    return { [sorts[0].field]: sorts[0].order };\n  }\n\n  return sorts.map((sort) => ({ [sort.field]: sort.order }));\n}\n","usedDeprecatedRules":[]}]
